--- status: DRAFT
--- author(s): DE
--- notes: 

document { 
     Key => quotient,
     Headline => "ideal or submodule quotient",
     Usage => "quotient(I,J)",
     Inputs => {"I" => " an ideal or submodule", 
	        "J" =>" an ideal, ring element, or submodule"
	  },
     Outputs => {
	  {TEX "the ideal or submodule $I:J = {f | fJ\\subset I}$"}
	  },
     Consequences => {
	  },     
     "Groebner bases will be computed as needed.",
     PARA,
     "The colon operator ", TO (symbol :), " may be used as an abbreviation 
     of ", TT "quotient", " if no options need to be supplied.",
     PARA,
     "If the second input ", TT "J", " is a ring element ", TT "f", 
     ", then the principal ideal generated by ", TT "f", " is used.",
     PARA,
     "The computation is not stored anywhere yet, BUT, it will soon be stored
     under I.cache.QuotientComputation{J}, or I.QuotientComputation{J},
     so that the computation can be restarted after an interrupt.",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {saturate},
     }
document { 
     Key => (quotient,Module,RingElement),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Module,Module),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Ideal,RingElement),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Module,Ideal),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Ideal,Ideal),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Matrix,GroebnerBasis),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => (quotient,Matrix,Matrix),
     Headline => "",
     Usage => "",
     Inputs => {
	  },
     Outputs => {
	  },
     Consequences => {
	  },     
     "description",
     EXAMPLE {
	  },
     Caveat => {},
     SeeAlso => {}
     }
document { 
     Key => [quotient, Strategy],
     Headline => "Possible strategies are: Iterate, Linear, and Quotient",
     Usage => "quotient(I,J,Strategy=>b)",
     Inputs => {"b"=>Symbol =>{"one of", TT " Iterate, Linear, Quotient"}
	  },
     "Suppose that I is the image of a free module FI in a quotient module G,
     and J is the image of the free module FJ in G.",
     PARA,PARA,
     "The default is ", TT "Strategy=>Quotient", ", which works as follows:",
     PARA,
     "If I is the image of a free module FI in a quotient module G,
     and J is the image of the free module FJ in G,
     then with this strategy quotient computes the first
     components of the syzygies of the sum ",BR,
     "map R++((dual FJ)**FI to (dual FJ) ** G. ",
     PARA,
     "If ", TT "Strategy=>Iterate", 
     " then quotient first computes the quotient I1 by the first generator of J.
     It then checks whether this quotient already annihilates the second generator of J mod I.
     If so, it goes on to the third generator; else
     it intersects I1 with the quotient of I by the second generator to produce a new I1.
     It then iterates this process, working through the generators one at a time.",
     PARA,
     "To use ", TT "Strategy=>Linear", 
     " the argument J must be a principal ideal, generated by a linear form. A change of variables is made
     so that this linear form becomes the last variable. Then a reverse lex Groebner basis is used,
     and the quotient of the initial ideal by the last variable is computed combinatorially. This
     set of monomial is then lifted back to a set of generators for the quotient.",
     PARA,
     "For further information see for example Exercise 15.41 in Eisenbud's Commutative Algebra with a View Towards Algebraic Geometry.",
      PARA,
     "The following examples show timings for the different strategies.",
     PARA,
     TT "Strategy=>Iterate", " is sometimes faster for ideals with a small number of generators:",
     EXAMPLE {      
         "n = 6",  
         "S = ZZ/101[vars(0..n-1)];",
         "i1 = monomialCurveIdeal(S, 1..n-1)",
         "i2 = monomialCurveIdeal(S, 1..n-1)",
         "j1 = ideal(map(S^1,S^n, (p,q)->S_q^5))",
         "j2 = ideal(map(S^1,S^n, (p,q)->S_q^5))",
         "time quotient(i1^3,j1^2,Strategy=>Iterate);",
         "time quotient(i2^3,j2^2,Strategy=>Quotient);"
        },
      TT "Strategy=>Quotient", " is faster in other cases:",
      EXAMPLE {
             "S =ZZ/101[vars(0..4)];",
             "i =ideal vars S;",
             "j =ideal vars S;",
             "i3 = i^3; i5 = i^5;",
             "j3 = j^3; j5 = j^5;",
             "time quotient(i5,i3,Strategy=>Iterate);",
             "time quotient(j5,j3,Strategy=>Quotient);"
      }
}



document { 
     Key => [quotient, MinimalGenerators],
     Headline => "Decides whether quotient computes and outputs a trimmed set of generators; default is true",
     Usage => "quotient(I,J,MinimalGenerators => b)",
     Inputs => {"b" => Boolean => {TT "true", " forces trimmed output."}
	  },
     EXAMPLE {
	  "S=ZZ/101[a,b]",
     	  "i=ideal(a^4,b^4)"},
	  "The following returns 2 minimal generators ",
	  "(Serre's Theorem: a codim 2 Gorenstein ideal is a complete intersection.)",
	EXAMPLE  "quotient(i, a^3+b^3)",
	  "Without trimming we'd get 4 generators instead.",
  	  EXAMPLE "quotient(i, a^3+b^3, MinimalGenerators=>false)",
     }

end
document {
     Key => [quotient,Iterate],
     TT "quotient(I,J,Strategy => v)", " -- an option which can
     be used to specify the strategy to be used in the computation.",
     PARA,
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "Iterate",
          TO "Linear"
          }
     }

 -- doc7.m2:1317:     Key => (subquotient,Matrix,Matrix),
 -- doc9.m2:794:     Key => quotient,
 -- doc9.m2:837:     Key => quotient,
 -- doc9.m2:867:     Key => [quotient,Strategy],
 -- doc9.m2:1211:     Key => [quotient,MinimalGenerators],
 -- overviewB.m2:295:     Key => "ideal quotients and saturation",
 -- overviewC.m2:610:     Key => "quotient rings",
 -- overviewC.m2:1238:     Key => "subquotient modules",
 -- overviewC.m2:1328:     Key => "what is a subquotient module?",
 -- overviewC.m2:1341:     Key => "extracting parts of a subquotient module",
 -- overviewC.m2:1346:     Key => "quotients of modules",

end

document {
     Key => quotient,
     Headline => "ideal or submodule quotient",
     Usage => "quotient(I,J) or I:J",
     Inputs => {
	  "I" => "an ideal or submodule",
	  "J" => "an ideal, ring element or submodule"
	  },
     Outputs => {
	  {"the ideal or submodule I:J.  See the appropriate 
	       subsection for the definition of I:J."}
	  },
     "Groebner bases will be computed as needed.",
     PARA,
     "The colon operator ", TO (symbol :), " may be used as an abbreviation 
     of ", TT "quotient", " if no options need to be supplied.",
     PARA,
     "If the second input ", TT "J", " is a ring element ", TT "f", 
     ", then the principal ideal generated by ", TT "f", " is used.",
     PARA,
     "The computation is not stored anywhere yet, BUT, it will soon be stored
     under I.cache.QuotientComputation{J}, or I.QuotientComputation{J},
     so that the computation can be restarted after an interrupt.",
     SeeAlso => {saturate},
     Subnodes => {
	  TO (quotient,Ideal,Ideal),
	  TO (quotient,Module,Ideal),
	  TO (quotient,Module,Module)
	  }
     }

document {
     Key => (symbol :, Ideal, Ideal),
     Headline => "ideal quotient",
     TT "I:J", " -- computes the ideal quotient.",
     PARA,
     "The notation ", TT "I:J", " is equivalent to ", TT "quotient(I,J)", ",
     although with the latter form, optional arguments can be provided.
     See ", TO quotient, " for further details."
     }

///
-- old, replaced documentation
document {
     Key => quotient,
     Headline => "ideal or submodule quotient",
     TT "quotient(I,J)", " -- computes the ideal or submodule quotient ", TT "(I:J)", ".", 
     PARA,
     "The arguments should be ideals in the same ring, or submodules of the same
     module.  If ", TT "J", " is a ring element, then the principal ideal 
     generated by ", TT "J", " is used.",
     PARA,
     "The operator ", TO ":", " can be used as an abbreviation, but without optional
     arguments; see ", TO (symbol :, Module, Module), ".",
     PARA,
     "For ideals, the quotient is the set of ring elements r such that rJ is
     contained in I.  If I is a submodule of a module M, and J is an ideal,
     the quotient is the set of elements m of M such that Jm is contained in
     I.  Finally, if I and J are submodules of the same module M, then the
     result is the set of ring elements r such that rJ is contained in I.",
     EXAMPLE {
	  "R = ZZ/32003[a..d];",
      	  "J = monomialCurveIdeal(R,{1,4,7})",
      	  "I = ideal(J_1-a^2*J_0,J_2-d*c*J_0)",
      	  "I : J",
	  },
     PARA,
     "The computation is currently not stored anywhere: this means
     that the computation cannot be continued after an interrupt.
     This will be changed in a later version."
     }
///

document {
     Key => [quotient,Strategy],
     TT "quotient(I,J,Strategy => v)", " -- an option which can
     be used to specify the strategy to be used in the computation.",
     PARA,
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "Iterate",
          TO "Linear"
          }
     }

TEST "
  -- quotient(Ideal,Ideal)
  -- quotient(Ideal,RingElement)
  -- options to test: DegreeLimit, BasisElementLimit, PairLimit, 
  --    MinimalGenerators,
  --    Strategy=>Iterate, Strategy=>Linear
  R = ZZ/101[a..d]
  I1 = monomialCurveIdeal(R, {1,3,7})
  I2 = ideal((gens I1)_{0,1})
  I3 = quotient(I2,I1)
  I4 = quotient(I2,I3)
  I5 = quotient(I2, c)

  assert(I2 == 
       intersect(I3,I4)
       )
  
  assert(ideal(c,d) ==
       quotient(I2, I5)
       )

  assert(I3 ==
       I2 : I1
       )

--  assert(ideal(d) + I2 ==
--       quotient(I2,I1,DegreeLimit=>1)
--       )

  assert(I3 ==
       quotient(I2,I1,Strategy=>Iterate)
       )
  
  quotient(I2,I1,MinimalGenerators=>false)
--  stderr << \"  -- this fails currently\" << endl
--  assert(I5 ==
--       quotient(I2, c,Strategy=>Linear)
--       )
  
"

TEST "
  -- quotient(Ideal,Ideal)
  -- quotient(Ideal,RingElement)
  -- options to test: DegreeLimit, BasisElementLimit, PairLimit, 
  --    MinimalGenerators,
  --    Strategy=>Iterate, Strategy=>Linear
  R = ZZ/101[vars(0..3)]/(a*d)
  I1 = ideal(a^3, b*d)
  I2 = ideal(I1_0)

  I3 = quotient(I2,I1)
  assert(I3 == ideal(a))
  I4 = quotient(I2,I3)
  assert(I4 == ideal(a^2,d))
  I5 = quotient(I2, d)
  assert(I5 == ideal(a))
"

TEST "
  --    quotient(Module,RingElement)
  --    quotient(Module,Ideal)
  
  -- This tests 'quotmod0' (default)
  R = ZZ/101[vars(0..4)]/e
  m = matrix{{a,c},{b,d}}
  M = subquotient(m_{0}, a^2**m_{0} | a*b**m_{1})
  J = ideal(a)
  Q1 = quotient(M,J)
  
  -- Now try the iterative version
  Q2 = quotient(M,J,Strategy=>Iterate)
  assert(Q1 == Q2)

  m = gens M  
  F = target m
  mm = generators M | relations M
  j = transpose gens J
  g = (j ** F) | (target j ** mm)
  h = syz gb(g, 
	  Strategy=>LongPolynomial,
	  SyzygyRows=>numgens F,
	  Syzygies=>true)
  trim subquotient(h % M.relations, 
             M.relations)
  
"

TEST "
  --    quotient(Module,Module)
  R = ZZ/101[a..d]
  M = image matrix{{a,b},{c,d}}
  N = super M
  I = quotient(M,N)
  assert(I ==
            quotient(M,N,Strategy=>Iterative)
	)
   
  assert(I == 
            M : N
	)
  assert(I ==
            ann(N/M)
	)
"

TEST "
  --    quotient(Module,Module)
  R = ZZ/101[vars(0..14)]
  N = coker genericMatrix(R,a,3,5)
  M = image N_{}
  I = quotient(M,N)
  assert(I ==
            quotient(M,N,Strategy=>Iterative)
	)
   
  assert(I == 
            M : N
	)
  assert(I ==
            ann(N/M)
	)
"

TEST "
  R = ZZ/101[a..d]
  M = coker matrix{{a,b},{c,d}}
  m1 = basis(2,M)
  image m1
  M1 = subquotient(matrix m1, relations M)
  Q1 = M1 : a  
  Q2 = quotient(M1,ideal(a,b,c,d),Strategy=>Iterate)
  assert(Q1 == Q2)
"

TEST "
  R = ZZ/101[a..d]
  mrels = matrix{{a,b},{c,d}}
  mgens = matrix(R,{{1,0},{0,0}})
  M = trim subquotient(mgens, mrels)
  Q1 = quotient(image M_{},a*d-b*c)
  assert(Q1 == super M)  -- fails: bug in == ...
"

TEST ///
-- Test of stopping conditions
R = QQ[a..d]
I = ideal(a^5,b^5,c^5,d^5)
I : (a+b+c+d)
quotient(I, a^2+b^2+c^2+d^2, DegreeLimit=>20)
gbTrace=3
quotient(I, a+b+c+d, BasisElementLimit=>5, MinimalGenerators=>false)
///