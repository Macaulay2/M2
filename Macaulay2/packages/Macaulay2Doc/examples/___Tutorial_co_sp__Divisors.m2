KK = ZZ/31991
SE = KK[x,y,z]/(y^2*z - x*(x-z)*(x+3*z))
purify1S2 = I -> (
    -- Assuming ring I is S2, and I is not 0, returns the 
    -- pure codimension 1 part of I.
    -- Find a nonzero element of I:
    M := compress gens I;
    -- Explanation: gens I is 
    -- the matrix of generators of I; compress
    -- removes the entries that are 0
    -- and := makes M a local variable.
    if numgens source M == 0 
    then error "purify1S2: expected nonzero ideal";
    f := ideal M_(0,0);
    -- f is the ideal generated by the first entry.
    -- Since ring I is S2, the ideal f is 
    -- pure codimension 1.  Thus
    f:(f:I)
    -- is the pure codimension 1 part. (The last 
    -- expression given in a function is the returned
    -- value, provided the semicolon is left off.)
    )
R = ZZ/5[a,b]
purify1S2 ideal(a^2,a*b)
Divisor = new Type of BasicList
divisor = method()
divisor(Ideal,Ideal) := (I,J) -> new Divisor from {purify1S2 I,purify1S2 J};
divisor Ideal := I -> divisor(I, ideal 1_(ring I));
P = divisor ideal(x,z)
R = divisor ideal(x,y)
R1 = divisor ideal(x-z,y)
R2 = divisor ideal(x+3*z,y)
Q1 = divisor ideal(y-6*z, x-3*z)
normalForm = method()
normalForm Divisor := D -> new Divisor from {D#0 : D#1, D#1 : D#0};
Divisor == Divisor := (D,E) -> toList normalForm D == toList normalForm E;
D = divisor(ideal(y, x^2+2*x*z-3*z^2), ideal(x-z, y))
normalForm D
D == R2
Divisor + Divisor := (D,E) -> divisor(D#0 * E#0, D#1 * E#1);
- Divisor := (D) -> new Divisor from {D#1, D#0};
Divisor - Divisor := (D,E) -> D + (-E);
ZZ Divisor := ZZ * Divisor := (n,D) -> divisor((D#0)^n, (D#1)^n);
2P
3P
D = P-R1
D2 = 2P - 2R1
D = 2P
I = D#0
J = D#1
f = z
LD = basis(degree f, purify1S2((f*J) : I))
LD = super (LD ** (ring target LD))
imI = purify1S2(((z+x)*I) : z)
degree imI
globalSections = method()
globalSections Divisor := (D) -> (
    -- First let's grab the parts (I,J) of D.
    I := D#0;
    J := D#1;
    -- Let 'f' be the first element of the 
    -- matrix of generators of the ideal I.
    f := (gens I)_(0,0);
    -- Now compute the basis of global sections
    -- just as above
    LD := basis(degree f, purify1S2((f*J) : I));
    LD = super (LD ** (ring target LD));
    -- Return both this vector space and the denominator
    {LD, f});
sectionIdeal = (f,g,D) -> (
    I := D#0;
    J := D#1;
    purify1S2((f*I):g) : J
    );
D = 4P
L = globalSections D
phi = map(SE, ZZ/31991[a..d], L#0)
ker phi
D = 4P - R
L = globalSections D
II = sectionIdeal(y*z+x*z+x^2, z^2, D)
degree II
globalSections (P-R)
D = 2 P - 2 R
LB = globalSections D
linearlyEquivalent = (D,E) -> (
    F := normalForm(D-E);
    LB := globalSections F;
    L := LB#0;
    -- L is the matrix of numerators. Thus numgens source L
    -- is the dimension of the space of global sections.
    if numgens source L != 1 
    then false
    else (
        R := ring L;
        V := sectionIdeal(L_(0,0), LB#1, F);
        if V == ideal(1_R) 
          then L_(0,0)/LB#1
          else false)
    );
linearlyEquivalent(P,R)
linearlyEquivalent(2P,2R)
effective = (D) -> (
    LB := globalSections D;
    L := LB#0;  -- the matrix of numerators
    if numgens source L == 0 
    then error(toString D + " is not effective")
    else divisor sectionIdeal(L_(0,0), LB#1, D));
effective(2R-P)
addition = (R,S) -> effective(R + S - P);
addition(R1,R2)
Q2 = addition(Q1, Q1)
Q3 = addition(Q2, Q1)
Q4 = addition(Q3, Q1)
Q4a = addition(Q2,Q2)
S = ZZ/31991[a,b,c,d];
catalect = map(S^2, 3, (i,j)->S_(i+j))
IC = minors(2, catalect)
SX = S/IC
KX = Ext^2(coker gens IC,S^{-4})
canpres = substitute(presentation(KX), SX)
betti canpres
I1 = transpose (syz transpose canpres)_{0}
dg = (degrees (target I1))_0_0
divisorFromModule = M -> (
  -- given a module M, returns the divisor of the image
  -- of a nonzero homomorphism to R, suitably twisted.
  -- first get the presentation of M
    I1 := transpose (syz transpose presentation M)_{0};
  -- The degree is
    d := (degrees target I1)_0_0;
  -- We need to balance the degree d with a power
  -- of the first nonzero generator of the ring.
    var1 := (compress vars ring M)_{0};
  -- Now fix up the degrees.
    if d==0 then divisor ideal I1
    else if d>0 then divisor(
                  ideal (I1**dual(target I1)),
                  ideal var1^d
                 )                          
    else divisor ideal( 
               var1^(-d)**I1**dual target I1
               )
);
M = coker canpres
divisorFromModule M
use SX
divisorFromModule image matrix{{d^2}}
divisorFromModule SX^{1}
canonicalDivisor= SX ->(
  -- Given a ring SX, computes a canonical divisor for SX
  I := ideal presentation SX;
  S := ring I;
  embcodim := codim I;
  M := Ext^embcodim(coker gens I,S^{-numgens S});
  M = coker substitute(presentation M, SX);
  divisorFromModule M
  );
canonicalDivisor SX
