import os
import os.path
import re
import subprocess
import shutil
Import('state','getState','setState','getLibSpecific','setLibSpecific','architecture','numberSubTasks')

dependencies = {
    'mpfr':'mpir',
    'cddlib':'mpir',
    'glpk':'mpir',
    'gfan':'cddlib',
    'cddplus':'cddlib'
}
#list of dependencies to build.
buildlibraries = set(['gc','mpir','readline','gdbm','mpfr','cddlib','glpk'])

def Glob( pattern = '*.*', dir = '.' ):
    import os, fnmatch
    files = []
    for file in os.listdir( Dir(dir).srcnode().abspath ):
        if fnmatch.fnmatch(file, pattern) :
            files.append( file )
    return files

def modeBuild(mode,architecture):
    """
    This function returns true if the mode should be built, false otherwise.
    """
    return getState(mode,architecture,'build')

def modeBuildPath(mode,architecture):
    """
    This function returns the build path for the current mode.
    """
    return "../"+getState(mode,architecture,'buildpath')

def modeTarPath(mode,architecture):
    """
    This function returns the tar path for the current mode.
    """
    return '../'+getState(mode,architecture,'tarpath')

def modeBuildPackageSets(mode,architecture):
    """
    This function is responsible for building lists of packages to build.
    It returns:
    A set of packages present
    A set of base packages present (defined to be the packages minus any extensions).
    """
    tarpath = modeTarPath(mode,architecture)
    packages = set(Glob(pattern='*.tar.gz',dir=tarpath)+Glob(pattern='*.tar.bz2',dir=tarpath))
    packageBases = set()
    for package in packages:
        package = extractPackageName(package)
        packageBases.add(package)
    setState(mode,architecture,'packages',packages)
    return packages, packageBases
    
def modeBuildExistingPackages(mode,architecture):
    """
    This function is responsible for building lists of existing packages.
    An existing package is one that exists in the build directory.
    """
    existingPackages = set()
    buildpath = modeBuildPath(mode,architecture)
    #Make the directory if it does not already exist.
    if(not os.path.isdir(buildpath)):
       os.makedirs(buildpath)
    #Check for existing packages by looking at directories in the build path.
    for partialPath in os.listdir(buildpath):
        if(not os.path.isdir(buildpath+partialPath)):
            continue
        if(partialPath[0]=='.'):
            continue
        existingPackages.add(partialPath)
    setState(mode,architecture,'existingpackages',existingPackages)
    
    return existingPackages

def modeBuildEnvironments(mode,architecture):
    """
    This function creates environments for the libraries to use.
    """
    if(not modeBuild(mode,architecture)):
        return
    env = Environment()
    env.mode = mode
    env.state = state
    setState(mode,architecture,'env',env)

def extractPackageName(package):
    """
    This function extracts the package name from a file.
    This is the file name minus the extension.
    """
    package = package.replace('.tar.gz','')
    package = package.replace('.tar.bz2','')
    return package

def extractPackageBaseName(package):
    """
    This extracts the package base name from a file.
    This is the beginning of the file name up to the first non-alpha numeric character.
    """
    if(package.find('nauty')==0):
        return 'nauty'
    if(package.find('gfan')==0):
        return 'gfan'
    if(package.find('cdd+')==0):
        return 'cddplus'
    return re.match('\A[0-9,a-z,A-Z]+',package).group(0)

def getConfigureCommand(state,mode,architecture):
    lsv = getLibSpecific(state,mode,architecture,"configure command")
    if(lsv):
        return lsv
    return "configure"

def getMakeCommand(state,mode,architecture):
    lsv = getLibSpecific(state,mode,architecture,"make command")
    if(lsv):
        return lsv
    return "make"

def getMakeInstallCommand(state,mode,architecture):
    lsv = getLibSpecific(state,mode,architecture,"make install command")
    if(lsv):
        return lsv
    return "make install"

def untarLibrary(state, mode, architecture, source, libraryName, libraryBaseName):
   """
   This untars the library if the appropriate state flags are set.
   Source is the source file.
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+libraryName+'/'
   #Check to see if it has already been extracted.
   if(not os.path.isdir(realpath)):
      #If not, copy the tarball and extract it.
       shutil.copy(source,buildpath)
       tarp = subprocess.Popen(['tar', '-xvf',sourceFile],cwd=buildpath)
       if(tarp.wait()):
           raise Exception("Unable to untar " + libraryName + ".")
       setLibSpecific(mode,architecture,libraryBaseName,'config',True)
       return True
   else:
       return False

def transferEnv(env,mode,architecture,library,attr):
   """
   If the given library specific attribute exists for the given mode and architecture, set it in the env dictionary
   """
   s = getLibSpecific(mode,architecture,library,attr)
   if(s):
       env[attr]=s
def appendEnv(env,attr,val):
    """
    Append the given enviroment variable onto the existing enviroment variable in a reasonable way.
    """
    if(env.get(attr)!=None):
        env[attr] = env[attr]+' '+ val
    else:
        env[attr]=val

def configureLibrary(state, mode, architecture, source, packageName, libraryBaseName):
   """
   Configure the given library
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+packageName+'/'
   if(getLibSpecific(mode,architecture,libraryBaseName,'config')==True):
       args = [os.path.abspath(realpath)+'/configure']
       configureArguments = getLibSpecific(mode,architecture,libraryBaseName,'configureArguments')
       if(configureArguments!=None):
           args = args + configureArguments
       installpath = os.path.abspath(getState(mode,architecture,'prefixpath')+mode)
       args = args + ['--prefix='+installpath]
       newEnv = os.environ
       appendEnv(newEnv,'CPPFLAGS','-I'+os.path.abspath(getState(mode,architecture,'prefixpath')+mode+'/include/'))
       appendEnv(newEnv,'LDFLAGS','-L'+os.path.abspath(getState(mode,architecture,'prefixpath')+mode+'/lib/'))
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CXXFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'FFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'FCFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CC')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CXX')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'CPPFLAGS')
       transferEnv(newEnv,mode,architecture,libraryBaseName,'LDFLAGS')

       configp = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(configp.wait()):
           raise Exception("Unable to configure " + packageName + ".")
       setLibSpecific(mode,architecture,libraryBaseName,'make',True)       

def makeLibrary(state, mode, architecture, source, packageName, libraryBaseName, newEnv = os.environ):
   """
   Make the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+packageName+'/'
   #need to separate out make and make install
   #for some libs such as mpir these are not equivalent.
   if(getLibSpecific(mode,architecture,libraryBaseName,'make')==True):
       extramake = getLibSpecific(mode,architecture,libraryBaseName,'makeArguments')
       args = ['make']
       if(extramake is not None):
           args = args + extramake
       if(getLibSpecific(mode,architecture,libraryBaseName,'enableParallelSubBuild')==True):
           args = args + ['-j'+str(numberSubTasks())]
           
       makep = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(makep.wait()):
           raise Exception("Unable to make " + packageName + ".")

def makeInstallLibrary(state, mode, architecture, source, libraryName, libraryBaseName, newEnv = os.environ):
   """
   Install the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+libraryName+'/'
   #need to separate out make and make install
   #for some libs such as mpir these are not equivalent.
   if(getLibSpecific(mode,architecture,libraryBaseName,'make')==True):
       extramake = getLibSpecific(mode,architecture,libraryBaseName,'makeArguments')
       args = ['make','install']
       if(extramake is not None):
           args = args + extramake
       newEnv = os.environ
       makep = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(makep.wait()):
           raise Exception("Unable to make install" + libraryName + ".")


def deepCleanLibrary(mode, architecture, packageBaseName):
    """
    Deep clean the given library.
    This removes the existing directory so the tarball will be reextracted
    """
    if(getState(mode,architecture,'deepcleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'deepclean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Deleting build directory for: ' + packageBaseName + ' at ' + directory
                Execute(Delete(directory))
        setLibSpecific(mode,architecture,packageBaseName,'config',True)
        return True
    else:
        return False
   
def cleanLibrary(mode, architecture, packageBaseName):
    """
    Clean the given library.
    This is equivalent to make clean.
    """
    if(getState(mode,architecture,'cleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'clean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Cleaning ' + packageBaseName + ' at ' + directory
                cleanp = subprocess.Popen(['make','clean'],cwd=directory)
                if(cleanp.wait()):
                    raise Exception("Unable to clean " + packageBaseName)
                setLibSpecific(mode,architecture,packageBaseName,'make',True)
        return True
    else:
        return False
    
#This holds a set of SConscripts that have already been imported.
importedSConscripts = set()

def modeImportSConscript(mode,packageBases):
    """
    This function imports SConscripts for packages.
    """
    for package in packageBases:
        package = extractPackageBaseName(package)
        if(not package in importedSConscripts):
            SConscript(package+'/SConscript',exports={
                    'state':state,
                    'extractPackageName':extractPackageName,
                    'extractPackageBaseName':extractPackageBaseName,
                    'getLibSpecific':getLibSpecific,
                    'setLibSpecific':setLibSpecific,
                    'getState':getState,
                    'setState':setState,
                    'untarLibrary':untarLibrary,
                    'transferEnv':transferEnv,
                    'configureLibrary':configureLibrary,
                    'makeLibrary':makeLibrary,
                    'makeInstallLibrary':makeInstallLibrary,
                    'deepCleanLibrary':deepCleanLibrary,
                    'cleanLibrary':cleanLibrary,
                    'architecture':architecture
                    })
            importedSConscripts.add(package)

    
def modeSpecific1(mode,architecture):
    """
    This is the first call to set up modes.
    """
    if(getState(mode,architecture,'build')==False):
        return
    try:
        os.makedirs(getState(mode,architecture,'prefixpath')+'lib/')
    except OSError:
        None
    try:
        os.makedirs(getState(mode,architecture,'prefixpath')+'include/')
    except OSError:
        None
    packages,packageBases = modeBuildPackageSets(mode,architecture)
    existingPackages = modeBuildExistingPackages(mode,architecture)
    modeBuildEnvironments(mode,architecture)
    setState(mode,architecture,'packagebases',packageBases)

def modeSpecific2(mode,architecture):
    if(modeBuild(mode,architecture)):
        modeImportSConscript(mode,getState(mode,architecture,'packagebases'))

def buildCandidates(mode,architecture):
    """
    This function assembles a list of build candidates.
    In the event of multiple files for the same library, the newest by creation date is used.
    """
    if(getState(mode,architecture,'build')==False):
        return
    packages = getState(mode,architecture,'packages')
    existingPackages = getState(mode,architecture,'existingpackages')
    tarpath = "../"+getState(mode,architecture,'tarpath')
    doBuildLibraries = {}
    for package in packages:
        libraryBaseName = extractPackageBaseName(package)
        if(libraryBaseName in buildlibraries):
            existingPackage = doBuildLibraries.get(libraryBaseName)
            if(existingPackage is not None):
                if(os.path.getmtime(tarpath+existingPackage) < os.path.getmtime(tarpath+package)):
                    doBuildLibraries[libraryBaseName]=package
            else:
                doBuildLibraries[libraryBaseName]=package
    return doBuildLibraries

#Setup the various modes.
for mode in state[architecture]['modes']:
    modeSpecific1(mode,architecture)
for mode in state[architecture]['modes']:
    modeSpecific2(mode,architecture)
for mode in state[architecture]['modes']:
    if(not getState(mode,architecture,'build')):
        continue
    builders = {}
    dbl = buildCandidates(mode,architecture)
    for libraryBase,library in dbl.items():
        libraryName = extractPackageName(library)
        builddir = '../'+getState(mode,architecture,'buildpath')
        source = '../'+getState(mode,architecture,'tarpath')+library
        builder = state[architecture][mode]['env'].__dict__['build_'+libraryBase](builddir+library,source)
        builders[libraryBase] = builder
        AlwaysBuild(builder)
    for target, tdependencies in dependencies.items():
        if(type(tdependencies) is list):
            for dependency in tdependencies:
                try:
                    Requires(builders[target],builders[dependency])
                except KeyError:
                    None
        else:
            try:
                Requires(builders[target],builders[tdependencies])
            except KeyError:
                None



