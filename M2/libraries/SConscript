import os
import os.path
import re
import subprocess
import shutil
Import('state','getState','setState','getLibSpecific','setLibSpecific','architecture','numberSubTasks',
        'setLibSpecificStateEnvExport','setLibSpecificConfigExport','setLibSpecificMakeExport','setLibSpecificMakeInstallExport','setLibSpecificNumStages','setLibSpecificStageCommandArguments',
        'setLibSpecificStageCommand','getLibSpecificStageEnvExport','getLibSpecificConfigEnv','getLibSpecificMakeEnv','getLibSpecificMakeInstallEnv','getLibSpecificNumStages','getLibSpecificStageCommandArguments',
        'getLibSpecificStageCommand','getLibSpecificEnv','Glob')

#list of dependencies to build.
buildlibraries = set(['gc','mpir','readline','gdbm','mpfr','cddlib','glpk','nauty','4ti2','lapack','lrslib','pari','ntl','factory','cddplus','frobby','gfan','libfac','normaliz','boost','libxml2'])
linuxBuildLibraries = buildlibraries
state['linux-x86_64']['buildlibraries']=linuxBuildLibraries
state['linux-x86']['buildlibraries']=linuxBuildLibraries

dependencies = {
    'sccfiles':['gc','gdbm'],
    'dstart':['scc','libfac','pari'],
    'm2':list(buildlibraries),
}

def downloadLibrary(architecture,mode,library):
    from urllib2 import Request, urlopen, URLError, HTTPError
    try:
        os.makedirs('../'+state[architecture][mode]['tarpath'])
    except:
        None
    libraryFile = getLibSpecific(mode,architecture,library,'CompressedLib')
    if libraryFile is None:
        raise Exception("Compressed Lib Name is None for " + library)
    filepath = '../'+state[architecture][mode]['tarpath'] + libraryFile
    absfilepath = os.path.abspath(filepath)
    if not os.path.isfile(filepath):
        if state['enabledownload']:
            url = getLibSpecific(mode,architecture,library,'downloadPath')
            if(url is None):
                url = 'http://www.math.uiuc.edu/Macaulay2/Extra/'
            url = url + libraryFile
            print 'Downloading: ' + absfilepath + ' from ' + url
            req = Request(url)
            f = urlopen(req)
            localFile = open(absfilepath,'w')
            localFile.write(f.read())
            localFile.close()
        else:
            raise Exception("Unable to find library: " + library + " and downloading libraries is disabled.")    

def downloadLibraries(architecture,mode):
    for library in buildlibraries:
        downloadLibrary(architecture,mode,library)

def modeBuild(mode,architecture):
    """
    This function returns true if the mode should be built, false otherwise.
    """
    return getState(mode,architecture,'build')

def modeBuildPath(mode,architecture):
    """
    This function returns the build path for the current mode.
    """
    return "../"+getState(mode,architecture,'buildpath')

def modeTarPath(mode,architecture):
    """
    This function returns the tar path for the current mode.
    """
    return '../'+getState(mode,architecture,'tarpath')
    
def modeBuildExistingPackages(mode,architecture):
    """
    This function is responsible for building lists of existing packages.
    An existing package is one that exists in the build directory.
    """
    existingPackages = set()
    buildpath = modeBuildPath(mode,architecture)
    #Make the directory if it does not already exist.
    if(not os.path.isdir(buildpath)):
       os.makedirs(buildpath)
    #Check for existing packages by looking at directories in the build path.
    for partialPath in os.listdir(buildpath):
        if(not os.path.isdir(buildpath+partialPath)):
            continue
        if(partialPath[0]=='.'):
            continue
        existingPackages.add(partialPath)
    setState(mode,architecture,'existingpackages',existingPackages)
    
    return existingPackages

def modeBuildEnvironments(mode,architecture):
    """
    This function creates environments for the libraries to use.
    """
    if(not modeBuild(mode,architecture)):
        return
    env = Environment()
    env.mode = mode
    env.state = state
    setState(mode,architecture,'env',env)

def extractPackageName(package):
    """
    This function extracts the package name from a file.
    This is the file name minus the extension.
    """
    package = package.replace('.tar.gz','')
    package = package.replace('.tar.bz2','')
    package = package.replace('.tgz','')
    package = package.replace('.zip','')
    return package

def extractPackageBaseName(package):
    """
    This extracts the package base name from a file.
    This is the beginning of the file name up to the first non-alpha numeric character.
    """
    if(package.find('nauty')==0):
        return 'nauty'
    if(package.find('gfan')==0):
        return 'gfan'
    if(package.find('cdd+')==0):
        return 'cddplus'
    if(package.find('Normaliz')==0):
        return 'normaliz'
    return re.match('\A[0-9,a-z,A-Z]+',package).group(0)

def untarLibrary(state, mode, architecture, source, libraryName, libraryBaseName):
   """
   This untars the library if the appropriate state flags are set.
   Source is the source file.
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+libraryName+'/'
   #Check to see if it has already been extracted.
   if(not os.path.isdir(realpath)):
      #If not, copy the tarball and extract it.
       shutil.copy(source,buildpath)
       tarp = subprocess.Popen(['tar', '-xvf',sourceFile],cwd=buildpath)
       if(tarp.wait()):
           unzipp = subprocess.Popen(['unzip', '-x',sourceFile],cwd=buildpath)
           if(unzipp.wait()):
               raise Exception("Unable to decompress " + libraryName + ".")
       setLibSpecific(mode,architecture,libraryBaseName,'stage0',True)
       tarfolder = getLibSpecific(mode,architecture,libraryBaseName,'tarfolder')
       if tarfolder:
           shutil.move(buildpath+tarfolder,realpath)
       patchfile = getLibSpecific(mode,architecture,libraryBaseName,'patchfile')
       if patchfile is None:
           return True
       patchargs = ['patch','-p1','--input='+patchfile]
       print "Patching " + str(patchargs)
       patchp = subprocess.Popen(patchargs,cwd=realpath)
       if(patchp.wait()):
           raise Exception("Unable to patch " + libraryBaseName + " " + libraryName + " in " + realpath)
       return True
   else:
       return False

def transferEnv(env,mode,architecture,library,attr):
   """
   If the given library specific attribute exists for the given mode and architecture, set it in the env dictionary
   """
   s = getLibSpecific(mode,architecture,library,attr)
   if(s):
       env[attr]=s
def appendEnv(env,attr,val):
    """
    Append the given enviroment variable onto the existing enviroment variable in a reasonable way.
    """
    if(env.get(attr)!=None):
        env[attr] = env[attr]+' '+ val
    else:
        env[attr]=val

def executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,stage,diroffset=None):
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+packageName+'/'
   buildDirectory = getLibSpecific(mode,architecture,libraryBaseName,'builddirectory')
   if(buildDirectory):
       realpath = realpath+buildDirectory
   stageoffset = getLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)+'DirOffset')
   if(stageoffset):
       realpath = realpath + stageoffset
   if(diroffset):
       realpath = realpath+diroffset
   if(getLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)) is True):
#       if(stage >= getLibSpecificNumStages(stage,mode,architecture)):
#           raise Exception("Stage " + str(stage) + " > " + str(getLibSpecificNumStages(stage,mode,architecture)))
       cmd = getLibSpecificStageCommand(mode,architecture,libraryBaseName,stage)
       if(cmd==''):
           return
       args = getLibSpecificStageCommandArguments(mode,architecture,libraryBaseName,stage)
       if(cmd!='make'):
           args = [os.path.abspath(realpath+cmd)]+args
       else:
           args = [cmd]+args
       newEnv = os.environ
       getLibSpecificEnv(mode,architecture,libraryBaseName,stage,newEnv)
       print 'Execute: ' + str(args) + " in " + realpath
       proc = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(proc.wait()):
           if(cmd=='bjam'):
               None
           else:
               raise Exception("Unable to execute " + str(args) + " for library " + packageName + " in " + realpath)
       setLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage+1),True)       
       return True
   else:
       return False
    
def configureLibrary(state, mode, architecture, source, packageName, libraryBaseName):
   """
   Configure the given library
   """
   return executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,0)

def makeLibrary(state, mode, architecture, source, packageName, libraryBaseName, diroffset = None):
   """
   Make the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,1,diroffset)

def makeInstallLibrary(state, mode, architecture, source, libraryName, libraryBaseName, diroffset = None):
   """
   Install the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(state,mode,architecture,source,libraryName,libraryBaseName,2,diroffset)

def deepCleanLibrary(mode, architecture, packageBaseName):
    """
    Deep clean the given library.
    This removes the existing directory so the tarball will be reextracted
    """
    if(getState(mode,architecture,'deepcleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'deepclean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Deleting build directory for: ' + packageBaseName + ' at ' + directory
                Execute(Delete(directory))
        setLibSpecific(mode,architecture,packageBaseName,'config',True)
        return True
    else:
        return False
   
def cleanLibrary(mode, architecture, packageBaseName):
    """
    Clean the given library.
    This is equivalent to make clean.
    """
    if(getState(mode,architecture,'cleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'clean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Cleaning ' + packageBaseName + ' at ' + directory
                cleanp = subprocess.Popen(['make','clean'],cwd=directory)
                if(cleanp.wait()):
                    raise Exception("Unable to clean " + packageBaseName)
                setLibSpecific(mode,architecture,packageBaseName,'make',True)
        return True
    else:
        return False
    
#This holds a set of SConscripts that have already been imported.
importedSConscripts = set()

def modeImportSConscript(mode,packageBases):
    """
    This function imports SConscripts for packages.
    """
    for package in packageBases:
        package = extractPackageBaseName(package)
        if(not package in importedSConscripts):
            SConscript(package+'/SConscript',exports={
                    'state':state,
                    'numberSubTasks':numberSubTasks,
                    'extractPackageName':extractPackageName,
                    'extractPackageBaseName':extractPackageBaseName,
                    'getLibSpecific':getLibSpecific,
                    'setLibSpecific':setLibSpecific,
                    'getState':getState,
                    'setState':setState,
                    'untarLibrary':untarLibrary,
                    'transferEnv':transferEnv,
                    'configureLibrary':configureLibrary,
                    'makeLibrary':makeLibrary,
                    'makeInstallLibrary':makeInstallLibrary,
                    'deepCleanLibrary':deepCleanLibrary,
                    'cleanLibrary':cleanLibrary,
                    'architecture':architecture,
                    'setLibSpecificStateEnvExport':setLibSpecificStateEnvExport,
                    'setLibSpecificConfigExport':setLibSpecificConfigExport,
                    'setLibSpecificMakeExport':setLibSpecificMakeExport,
                    'setLibSpecificMakeInstallExport':setLibSpecificMakeInstallExport,
                    'setLibSpecificNumStages':setLibSpecificNumStages,
                    'setLibSpecificStageCommandArguments':setLibSpecificStageCommandArguments,
                    'setLibSpecificStageCommand':setLibSpecificStageCommand,
                    'getLibSpecificStageEnvExport':getLibSpecificStageEnvExport,
                    'getLibSpecificConfigEnv':getLibSpecificConfigEnv,
                    'getLibSpecificMakeEnv':getLibSpecificMakeEnv,
                    'getLibSpecificMakeInstallEnv':getLibSpecificMakeInstallEnv,
                    'getLibSpecificNumStages':getLibSpecificNumStages,
                    'getLibSpecificStageCommandArguments':getLibSpecificStageCommandArguments,
                    'getLibSpecificStageCommand':getLibSpecificStageCommand,
                    'executeStageLibrary':executeStageLibrary,
                    'buildBuilders':buildBuilders,
                    })
            importedSConscripts.add(package)
            deps = getLibSpecific(mode,architecture,package,'Dependencies')
            if deps:
                dependencies[package]=deps

    
def modeSpecific1(mode,architecture):
    """
    This is the first call to set up modes.
    """
    if(getState(mode,architecture,'build')==False):
        return
    try:
        libdirpath = os.path.abspath('../'+getState(mode,architecture,'prefixpath')+'lib/')
        os.makedirs(libdirpath)
    except OSError:
        None
    try:
        includedirpath = os.path.abspath('../'+getState(mode,architecture,'prefixpath')+'include/')
        os.makedirs(includedirpath)
    except OSError:
        None
    packageBases = state[architecture]['buildlibraries']
    existingPackages = modeBuildExistingPackages(mode,architecture)
    modeBuildEnvironments(mode,architecture)
    setState(mode,architecture,'packagebases',packageBases)

def modeSpecific2(mode,architecture):
    if(modeBuild(mode,architecture)):
        modeImportSConscript(mode,getState(mode,architecture,'packagebases'))
    downloadLibraries(architecture,mode)

def buildCandidates(mode,architecture):
    """
    This function assembles a list of build candidates.
    In the event of multiple files for the same library, the newest by creation date is used.
    """
    if(getState(mode,architecture,'build')==False):
        return
    packages = [getLibSpecific(mode,architecture,library,'CompressedLib') for library in getState(mode,architecture,'packagebases')]
    existingPackages = getState(mode,architecture,'existingpackages')
    tarpath = "../"+getState(mode,architecture,'tarpath')
    doBuildLibraries = {}
    for package in packages:
        libraryBaseName = extractPackageBaseName(package)
        if(libraryBaseName in buildlibraries):
            existingPackage = doBuildLibraries.get(libraryBaseName)
            if(existingPackage is not None):
                if(os.path.getmtime(tarpath+existingPackage) < os.path.getmtime(tarpath+package)):
                    doBuildLibraries[libraryBaseName]=package
            else:
                doBuildLibraries[libraryBaseName]=package
    return doBuildLibraries

def buildBuilders(libraryName):
    """
    Build build functions for the given library.
    """
    def BuildLibrary(target,source,env):
        """
        Build target for the library.
        """
        source = source[0].rstr()
        sourceFile = os.path.split(source)[1]
        packageName = extractPackageName(sourceFile)
        cleaned = CleanLibrary(env.mode,architecture,libraryName)
        if getLibSpecific(env.mode,architecture,libraryName,'DecompressLib') is True:
            untarLibrary(env.state,env.mode,architecture,source, packageName, libraryName)
            numstages = getLibSpecificNumStages(env.mode,architecture,libraryName)
            for i in range(0,numstages):
                executeStageLibrary(env.state,env.mode,architecture,source,packageName,libraryName,i)
            return None
            
            
    def CleanLibrary(mode,directory,packageBaseName):
        """
        Actual function that gets called to process a clean library command
        """
        if(deepCleanLibrary(mode,architecture,libraryName)):
            return True
        if(cleanLibrary(mode,architecture,libraryName)):
            return True   
        return False

    for mode in state[architecture]['modes']:
        if(getState(mode,architecture,'build')):
            builder = Builder(action=BuildLibrary, single_source=1)
            getState(mode,architecture,'env').Append(BUILDERS = {'build_'+libraryName : builder})
            if(state[architecture][mode].get('builders')==None):
                setState(mode,architecture,'builders',{})
            getState(mode,architecture,'builders')[libraryName]=builder

def createBuilders(mode,architecture,libraryBase,builders):
    library = getLibSpecific(mode,architecture,libraryBase,'CompressedLib')
    source = '../'+getState(mode,architecture,'tarpath')+library
    builder = state[architecture][mode]['env'].__dict__['build_'+libraryBase](builddir+library,source)
    builders[libraryBase] = builder
    AlwaysBuild(builder)
    setLibSpecific(mode,architecture,libraryBase,'stage0',True)
    #recursively rebuild library dependencies.
    for dlibrary,deps in dependencies.items():
        if not dlibrary in state[architecture]['buildlibraries']:
            continue
        if libraryBase in deps:
            if not builders.has_key(dlibrary):
                createBuilders(mode,architecture,dlibrary,builders)
    

#Setup the various modes.
for mode in state[architecture]['modes']:
    modeSpecific1(mode,architecture)
for mode in state[architecture]['modes']:
    modeSpecific2(mode,architecture)
for mode in state[architecture]['modes']:
    if(not getState(mode,architecture,'build')):
        continue
    builders = {}
    builders['dstart'] = getState(mode,architecture,'dstart')
    builders['scc'] = getState(mode,architecture,'scc')
    builders['sccfiles'] = getState(mode,architecture,'sccfiles')
    builders['m2']=getState(mode,architecture,'m2')
    dbl = buildCandidates(mode,architecture)
    for libraryBase,library in dbl.items():
        libraryName = extractPackageName(library)
        builddir = '../'+getState(mode,architecture,'buildpath')
        source = '../'+getState(mode,architecture,'tarpath')+library
        build = False
        for f in getLibSpecific(mode,architecture,libraryBase,'InstallFiles'):
            prefixpath = getState(mode,architecture,'prefixpath')
            f = f.replace("$SConsInstallPrefixPath",os.path.abspath('../'+prefixpath))
            if not os.path.exists(f):
                build = True
        if(getState(mode,architecture,'deepcleanlib',exception=False)==True or getLibSpecific(mode,architecture,libraryBase,'deepclean')==True):
            build = True
        elif(getState(mode,architecture,'cleanlib',exception=False)==True or getLibSpecific(mode,architecture,libraryBase,'clean')==True):
            build = True
        if build:
            createBuilders(mode,architecture,libraryBase,builders)

    for target, tdependencies in dependencies.items():
        if not builders.has_key(target):
            continue
        btarget = builders[target]
        if(type(tdependencies) is list):
            if(type(btarget) is list):
                for bltarget in btarget:
                    for dependency in tdependencies:
                        if(builders.has_key(dependency)):
                            Requires(bltarget,builders[dependency])
            else:
                for dependency in tdependencies:
                    if(builders.has_key(dependency)):
                        Requires(btarget,builders[dependency])                
        else:
            if(builders.has_key(tdependency)):
                Requires(btarget,builders[tdependencies])





