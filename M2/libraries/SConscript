import os
import os.path
import re
import subprocess
import shutil
Import('state','getState','setState','getLibSpecific','setLibSpecific','architecture','numberSubTasks',
        'setLibSpecificStateEnvExport','setLibSpecificConfigExport','setLibSpecificMakeExport','setLibSpecificMakeInstallExport','setLibSpecificNumStages','setLibSpecificStageCommandArguments',
        'setLibSpecificStageCommand','getLibSpecificStageEnvExport','getLibSpecificConfigEnv','getLibSpecificMakeEnv','getLibSpecificMakeInstallEnv','getLibSpecificNumStages','getLibSpecificStageCommandArguments',
        'getLibSpecificStageCommand','getLibSpecificEnv','Glob')

dependencies = {
    'mpfr':'mpir',
    'cddlib':'mpir',
    'glpk':'mpir',
    'gfan':'cddlib',
    'nauty':'mpir',
    '4ti2':['mpir','glpk'],
    'cddplus':'cddlib',
    'lrslib':'mpir',
    'pari':'mpir',
    'frobby':'mpir',
    'normaliz':['boost','mpir'],
    'sccfiles':['gc','gdbm'],
    #serialize
    'ntl':['mpir','pari','lrslib','cddplus','4ti2','nauty','gfan','glpk','cddlib','mpfr','readline','gdbm','gc','boost'],
    'factory':'ntl',
    'libfac':'factory',
}
#list of dependencies to build.
buildlibraries = set(['gc','mpir','readline','gdbm','mpfr','cddlib','glpk','nauty','4ti2','lapack','lrslib','mpir','pari','ntl','factory','cddplus','frobby','gfan','libfac','normaliz','boost'])
linuxBuildLibraries = buildlibraries
state['linux-x86_64']['buildlibraries']=linuxBuildLibraries
state['linux-x86']['buildlibraries']=linuxBuildLibraries
linuxVersions = ['4ti2-1.3.2.tar.gz','gfan0.4plus.tar.gz','Normaliz2.7.zip','boost_1_46_1.tar.gz','glpk-4.44.tar.gz','ntl-5.5.2.tar.gz',
                 'cdd+-077a.tar.gz','lapack-3.2.2.tgz','pari-2.5.0.tar.gz','cddlib-094f.tar.gz','libfac-3-1-3.tar.gz','factory-3-1-3.tar.gz',
                 'lrslib-042c.tar.gz','readline61-002','frobby_v0.8.2.tar.gz','mpfr-3.0.1.tar.gz','readline-6.1.tar.gz','gc-7.2alpha7.tar.gz',
                 'mpir-2.4.0.tar.bz2','gdbm-1.8.3.tar.gz','nauty24r2.tar.gz']
state['linux-x86_64']['tarfiles']=linuxVersions
state['linux-x86']['tarfiles']=linuxVersions

def downloadLibraries(architecture,mode):
    from urllib2 import Request, urlopen, URLError, HTTPError
    libraries = state[architecture]['tarfiles']
    try:
        os.makedirs(state[architecture][mode]['tarpath'])
    except:
        None
    for library in libraries:
        filepath = '../'+state[architecture][mode]['tarpath']+library
        absfilepath = os.path.abspath(filepath)
        if not os.path.isfile(filepath):
            print 'Downloading: ' + absfilepath
            if state['enabledownload']:
                url = 'http://www.math.uiuc.edu/Macaulay2/Extra/'+library
                req = Request(url)
                f = urlopen(req)
                localFile = open(absfilepath,'w')
                localFile.write(f.read())
                localFile.close()
            else:
                raise Exception("Unable to find library: " + library + " and downloading libraries is disabled.")

def modeBuild(mode,architecture):
    """
    This function returns true if the mode should be built, false otherwise.
    """
    return getState(mode,architecture,'build')

def modeBuildPath(mode,architecture):
    """
    This function returns the build path for the current mode.
    """
    return "../"+getState(mode,architecture,'buildpath')

def modeTarPath(mode,architecture):
    """
    This function returns the tar path for the current mode.
    """
    return '../'+getState(mode,architecture,'tarpath')

def modeBuildPackageSets(mode,architecture):
    """
    This function is responsible for building lists of packages to build.
    It returns:
    A set of packages present
    A set of base packages present (defined to be the packages minus any extensions).
    """
    tarpath = modeTarPath(mode,architecture)
    packages = set(Glob(pattern='*.tar.gz',dir=tarpath)+Glob(pattern='*.tar.bz2',dir=tarpath)+Glob(pattern='*.tgz',dir=tarpath)+Glob(pattern='*.zip',dir=tarpath))
    print packages
    packageBases = set()
    for package in packages:
        package = extractPackageName(package)
        packageBases.add(package)
    print packageBases
    setState(mode,architecture,'packages',packages)
    return packages, packageBases
    
def modeBuildExistingPackages(mode,architecture):
    """
    This function is responsible for building lists of existing packages.
    An existing package is one that exists in the build directory.
    """
    existingPackages = set()
    buildpath = modeBuildPath(mode,architecture)
    #Make the directory if it does not already exist.
    if(not os.path.isdir(buildpath)):
       os.makedirs(buildpath)
    #Check for existing packages by looking at directories in the build path.
    for partialPath in os.listdir(buildpath):
        if(not os.path.isdir(buildpath+partialPath)):
            continue
        if(partialPath[0]=='.'):
            continue
        existingPackages.add(partialPath)
    setState(mode,architecture,'existingpackages',existingPackages)
    
    return existingPackages

def modeBuildEnvironments(mode,architecture):
    """
    This function creates environments for the libraries to use.
    """
    if(not modeBuild(mode,architecture)):
        return
    env = Environment()
    env.mode = mode
    env.state = state
    setState(mode,architecture,'env',env)

def extractPackageName(package):
    """
    This function extracts the package name from a file.
    This is the file name minus the extension.
    """
    package = package.replace('.tar.gz','')
    package = package.replace('.tar.bz2','')
    package = package.replace('.tgz','')
    package = package.replace('.zip','')
    return package

def extractPackageBaseName(package):
    """
    This extracts the package base name from a file.
    This is the beginning of the file name up to the first non-alpha numeric character.
    """
    if(package.find('nauty')==0):
        return 'nauty'
    if(package.find('gfan')==0):
        return 'gfan'
    if(package.find('cdd+')==0):
        return 'cddplus'
    if(package.find('Normaliz')==0):
        return 'normaliz'
    return re.match('\A[0-9,a-z,A-Z]+',package).group(0)

def untarLibrary(state, mode, architecture, source, libraryName, libraryBaseName):
   """
   This untars the library if the appropriate state flags are set.
   Source is the source file.
   """
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+libraryName+'/'
   #Check to see if it has already been extracted.
   if(not os.path.isdir(realpath)):
      #If not, copy the tarball and extract it.
       shutil.copy(source,buildpath)
       tarp = subprocess.Popen(['tar', '-xvf',sourceFile],cwd=buildpath)
       if(tarp.wait()):
           unzipp = subprocess.Popen(['unzip', '-x',sourceFile],cwd=buildpath)
           if(unzipp.wait()):
               raise Exception("Unable to decompress " + libraryName + ".")
       setLibSpecific(mode,architecture,libraryBaseName,'stage0',True)
       patchfile = getLibSpecific(mode,architecture,libraryBaseName,'patchfile')
       if patchfile is None:
           return True
       patchargs = ['patch','-p1','--input='+patchfile]
       print "Patching " + str(patchargs)
       patchp = subprocess.Popen(patchargs,cwd=realpath)
       if(patchp.wait()):
           raise Exception("Unable to patch " + patch + " in " + realpath)
       return True
   else:
       return False

def transferEnv(env,mode,architecture,library,attr):
   """
   If the given library specific attribute exists for the given mode and architecture, set it in the env dictionary
   """
   s = getLibSpecific(mode,architecture,library,attr)
   if(s):
       env[attr]=s
def appendEnv(env,attr,val):
    """
    Append the given enviroment variable onto the existing enviroment variable in a reasonable way.
    """
    if(env.get(attr)!=None):
        env[attr] = env[attr]+' '+ val
    else:
        env[attr]=val

def executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,stage,diroffset=None):
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = getState(mode,architecture,'buildpath')
   #realpath is the path to extract to.
   realpath = buildpath+packageName+'/'
   buildDirectory = getLibSpecific(mode,architecture,libraryBaseName,'builddirectory')
   if(buildDirectory):
       realpath = realpath+buildDirectory
   if(diroffset):
       realpath = realpath+diroffset
   if(getLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)) is True):
#       if(stage >= getLibSpecificNumStages(stage,mode,architecture)):
#           raise Exception("Stage " + str(stage) + " > " + str(getLibSpecificNumStages(stage,mode,architecture)))
       cmd = getLibSpecificStageCommand(mode,architecture,libraryBaseName,stage)
       if(cmd==''):
           return
       args = getLibSpecificStageCommandArguments(mode,architecture,libraryBaseName,stage)
       if(cmd!='make'):
           args = [os.path.abspath(realpath+cmd)]+args
       else:
           args = [cmd]+args
       newEnv = os.environ
       getLibSpecificEnv(mode,architecture,libraryBaseName,stage,newEnv)
       print 'Execute: ' + str(args)
       proc = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(proc.wait()):
           raise Exception("Unable to execute " + str(args) + " for library " + packageName + " in " + realpath)
       setLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage+1),True)       
       return True
   else:
       return False
    
def configureLibrary(state, mode, architecture, source, packageName, libraryBaseName):
   """
   Configure the given library
   """
   return executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,0)

def makeLibrary(state, mode, architecture, source, packageName, libraryBaseName, diroffset = None):
   """
   Make the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(state,mode,architecture,source,packageName,libraryBaseName,1,diroffset)

def makeInstallLibrary(state, mode, architecture, source, libraryName, libraryBaseName, diroffset = None):
   """
   Install the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(state,mode,architecture,source,libraryName,libraryBaseName,2,diroffset)

def deepCleanLibrary(mode, architecture, packageBaseName):
    """
    Deep clean the given library.
    This removes the existing directory so the tarball will be reextracted
    """
    if(getState(mode,architecture,'deepcleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'deepclean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Deleting build directory for: ' + packageBaseName + ' at ' + directory
                Execute(Delete(directory))
        setLibSpecific(mode,architecture,packageBaseName,'config',True)
        return True
    else:
        return False
   
def cleanLibrary(mode, architecture, packageBaseName):
    """
    Clean the given library.
    This is equivalent to make clean.
    """
    if(getState(mode,architecture,'cleanlib',exception=False)==True or getLibSpecific(mode,architecture,packageBaseName,'clean')==True):
        existingPackages = getState(mode,architecture,'existingpackages')
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Cleaning ' + packageBaseName + ' at ' + directory
                cleanp = subprocess.Popen(['make','clean'],cwd=directory)
                if(cleanp.wait()):
                    raise Exception("Unable to clean " + packageBaseName)
                setLibSpecific(mode,architecture,packageBaseName,'make',True)
        return True
    else:
        return False
    
#This holds a set of SConscripts that have already been imported.
importedSConscripts = set()

def modeImportSConscript(mode,packageBases):
    """
    This function imports SConscripts for packages.
    """
    for package in packageBases:
        package = extractPackageBaseName(package)
        if(not package in importedSConscripts):
            SConscript(package+'/SConscript',exports={
                    'state':state,
                    'extractPackageName':extractPackageName,
                    'extractPackageBaseName':extractPackageBaseName,
                    'getLibSpecific':getLibSpecific,
                    'setLibSpecific':setLibSpecific,
                    'getState':getState,
                    'setState':setState,
                    'untarLibrary':untarLibrary,
                    'transferEnv':transferEnv,
                    'configureLibrary':configureLibrary,
                    'makeLibrary':makeLibrary,
                    'makeInstallLibrary':makeInstallLibrary,
                    'deepCleanLibrary':deepCleanLibrary,
                    'cleanLibrary':cleanLibrary,
                    'architecture':architecture,
                    'setLibSpecificStateEnvExport':setLibSpecificStateEnvExport,
                    'setLibSpecificConfigExport':setLibSpecificConfigExport,
                    'setLibSpecificMakeExport':setLibSpecificMakeExport,
                    'setLibSpecificMakeInstallExport':setLibSpecificMakeInstallExport,
                    'setLibSpecificNumStages':setLibSpecificNumStages,
                    'setLibSpecificStageCommandArguments':setLibSpecificStageCommandArguments,
                    'setLibSpecificStageCommand':setLibSpecificStageCommand,
                    'getLibSpecificStageEnvExport':getLibSpecificStageEnvExport,
                    'getLibSpecificConfigEnv':getLibSpecificConfigEnv,
                    'getLibSpecificMakeEnv':getLibSpecificMakeEnv,
                    'getLibSpecificMakeInstallEnv':getLibSpecificMakeInstallEnv,
                    'getLibSpecificNumStages':getLibSpecificNumStages,
                    'getLibSpecificStageCommandArguments':getLibSpecificStageCommandArguments,
                    'getLibSpecificStageCommand':getLibSpecificStageCommand,
                    'executeStageLibrary':executeStageLibrary,
                    })
            importedSConscripts.add(package)

    
def modeSpecific1(mode,architecture):
    """
    This is the first call to set up modes.
    """
    if(getState(mode,architecture,'build')==False):
        return
    print "Building " + mode + " on " + architecture
    downloadLibraries(architecture,mode)
    try:
        libdirpath = os.path.abspath('../'+getState(mode,architecture,'prefixpath')+'lib/')
        os.makedirs(libdirpath)
    except OSError:
        None
    try:
        includedirpath = os.path.abspath('../'+getState(mode,architecture,'prefixpath')+'include/')
        os.makedirs(includedirpath)
    except OSError:
        None
    packages,packageBases = modeBuildPackageSets(mode,architecture)
    existingPackages = modeBuildExistingPackages(mode,architecture)
    modeBuildEnvironments(mode,architecture)
    setState(mode,architecture,'packagebases',packageBases)

def modeSpecific2(mode,architecture):
    if(modeBuild(mode,architecture)):
        modeImportSConscript(mode,getState(mode,architecture,'packagebases'))

def buildCandidates(mode,architecture):
    """
    This function assembles a list of build candidates.
    In the event of multiple files for the same library, the newest by creation date is used.
    """
    if(getState(mode,architecture,'build')==False):
        return
    packages = getState(mode,architecture,'packages')
    existingPackages = getState(mode,architecture,'existingpackages')
    tarpath = "../"+getState(mode,architecture,'tarpath')
    doBuildLibraries = {}
    for package in packages:
        libraryBaseName = extractPackageBaseName(package)
        if(libraryBaseName in buildlibraries):
            existingPackage = doBuildLibraries.get(libraryBaseName)
            if(existingPackage is not None):
                if(os.path.getmtime(tarpath+existingPackage) < os.path.getmtime(tarpath+package)):
                    doBuildLibraries[libraryBaseName]=package
            else:
                doBuildLibraries[libraryBaseName]=package
    return doBuildLibraries

#Setup the various modes.
for mode in state[architecture]['modes']:
    modeSpecific1(mode,architecture)
for mode in state[architecture]['modes']:
    modeSpecific2(mode,architecture)
for mode in state[architecture]['modes']:
    if(not getState(mode,architecture,'build')):
        continue
    builders = {}
    dbl = buildCandidates(mode,architecture)
    for libraryBase,library in dbl.items():
        libraryName = extractPackageName(library)
        builddir = '../'+getState(mode,architecture,'buildpath')
        source = '../'+getState(mode,architecture,'tarpath')+library
        builder = state[architecture][mode]['env'].__dict__['build_'+libraryBase](builddir+library,source)
        builders[libraryBase] = builder
        AlwaysBuild(builder)
    for target, tdependencies in dependencies.items():
        if(target == 'scc'):
            btarget=state[architecture][mode]['scc']
        elif target == 'sccfiles':
            btarget=state[architecture][mode]['sccfiles']
        else:
            btarget = builders[target]
        if(type(tdependencies) is list):
            if(type(btarget) is list):
                for bltarget in btarget:
                    for dependency in tdependencies:
                        Requires(bltarget,builders[dependency])
            else:
                for dependency in tdependencies:
                    Requires(btarget,builders[dependency])                
        else:
            Requires(btarget,builders[tdependencies])





