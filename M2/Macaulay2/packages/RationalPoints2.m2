-------------------------------------------------------------------------------
-- licensed under GPL v2 or any later version
-------------------------------------------------------------------------------
newPackage(
    "RationalPoints2",
    Version => "0.3",
    Date => "Jan 24, 2021",
    Authors => { {Name => "Jieao Song", Email => "jieao.song@imj-prg.fr"} },
    Headline => "find the rational points on a variety",
    Keywords => {"Commutative Algebra"},
    DebuggingMode => false
)
-------------------------------------------------------------------------------
-- This program takes in an ideal generated by a list of polynomials, and finds
-- all of the common zeroes of the polynomials. Over a finite field the ideal
-- can be arbitrary; over a number field it must be of dimension 0.
-------------------------------------------------------------------------------
-- For a 0-dimensional ideal, the zeros are found using elimination theory,
-- which works over finite or infinite fields.
-------------------------------------------------------------------------------
-- For a positive dimensional ideal over a finite field, the program naively
-- tests points coordinate by coordinate. There are however several tricks used
-- to improve the performance.
--
-- * If at some coordinate we encounter some univariate polynomials, we test
-- only with their common roots instead of using the entire field k.
--
-- * If we get a prime ideal of degree 1, we solve a linear system of equations
-- to quickly get all the points contained in the corresponding linear
-- subspace.
--
-- * If the ideal is homogeneous, we will enumerate the rational points in the
-- projective space first, then reconstruct the points in the affine space;
-- this can also be done recursively.
--
-- * If we get a 0-dimensional ideal with relative small degree, we again use
-- the eliminant to solve the system.
-------------------------------------------------------------------------------
export{"rationalPoints", "Amount"}
-------------------------------------------------------------------------------
-- rings: a list of polynomial rings in increasing variable numbers
-- i.e. {k[], k[x], k[x,y], ...}
local rings;
-- els: a list of elements in the finite field k
local els;
-------------------------------------------------------------------------------
-- takes in a finite field and returns the list of its elements
--
listFieldElements = (k) -> (
    if isFinitePrimeField k then return apply(char k, i->i*1_k);
    -- if k is constructed using `toField`
    if not instance(k, GaloisField) then (
        try k = GF last k.baseRings
        else error "the coefficient ring is not a field";
    );
    x := k.PrimitiveElement;
    p := k.char;
    d := k.degree;
    try return {0_k} | (for e in (1..<p^d) list x^e*1_k)
    else error "the field is too big";
);
-------------------------------------------------------------------------------
-- takes a number n and a list
-- produces the direct product of the list with itself n times
-- same as lst**lst**lst**... but with flattened elements
--
pow = (n, lst) -> (
    if n < 0 then error "power of a list is not defined for n negative";
    result := {{}};
    for i in (0..<n) do result = flatten \ (result ** lst);
    return result;
);
-------------------------------------------------------------------------------
-- utility function that shuffles two list u and v according to a list ind
-- of indices in 0 (for u) and 1 (for v)
--
shuffle = (ind, u, v) -> (
    (i,j) := (-1,-1);
    return for k in (0..<#ind) list if ind_k==0 then (i=i+1; u_i) else (j=j+1; v_j);
);
-------------------------------------------------------------------------------
-- takes in a list of coefficients representing a univariate polynomial
-- returns the list of zeros
-- e.g. {2,-3,1} -> 2-3*x+x^2 which returns {1, 2}
--
zeros := (coeffs) -> (
    R := rings_1;
    y := R_0;
    k := coefficientRing R;
    p := null;
    getValue := (R, c) -> -coefficient(1_R, c) / coefficient(R_0, c);
    if char k > 0 or k === QQ then (
        p = sum apply(#coeffs, i->coeffs_i*y^i);
        factors := toList select(factor p, c->(degree value first c == {1}));
        return getValue_R \ value \ first \ factors;
    ) else ( -- over k where `factor` is not defined, we use `decompose`
        k' := last k.baseRings;
        R = k'(monoid[y]);
        y = R_0;
        p = sum apply(#coeffs, i->sub(coeffs_i, k')*y^i);
        comps := select(decompose(ideal p, Strategy=>"Legacy"), c->(degree c == degree k'));
        return (c->sub(getValue_R (gens c)_(0,0), k)) \ comps;
    );
);
zeros = memoize zeros;
-------------------------------------------------------------------------------
-- takes in a linear ideal and returns the list of solutions
--
linearSolve := (I) -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    system := first entries gens gb I;
    if system == {} then return pow_n els;
    -- solve a system of linear equations Ax=b
    A := matrix apply(system, f->apply(x, xi->coefficient(xi, f)));
    b := matrix apply(system, f->{-coefficient(1_R, f)});
    v := transpose solve(A, b);
    if #system == n then return {first entries v};
    M := transpose gens kernel A;
    getSolution := x -> first entries (v + matrix{toList x} * M);
    return getSolution \ pow_(n-#system) els;
);
linearSolve = memoize linearSolve;
-------------------------------------------------------------------------------
-- utility function that normalizes a list of homogeneous coordinates so that
-- the first non-zero coordinate is 1
--
homoCoord = p -> (a := p_(position(p, x->(x!=0))); (x->x/a) \ p);
-------------------------------------------------------------------------------
-- the main function that carries out the enumeration of points
-- takes in an ideal and enumerate the points coordinate by coordinate
-- returns the list of points or the number of points if `Amount` is set to
-- true
--
-- the ideal is ALWAYS assumed to be non-trivial, i.e. not (1)
--
findPoints = method(Options => {Amount=>false});
findPoints(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    result := null;
    (dimI, degI) := (dim I, degree I);
    -- use `linearSolve` if I is linear
    if degI == 1 and (dimI == 0 or isPrime I) then (
        if opts.Amount then return (#els)^(dimI)
        else return linearSolve I;
    );
    -- use `findProjPoints` if I is homogeneous
    if isHomogeneous I then (
        result = findProjPoints(I, Amount=>opts.Amount);
        if opts.Amount then return 1+(#els-1)*result
        else return {toList(n:0_k)} | join flatten((v->(a->a*v)\els_{1..<#els}) \ result);
    );
    -- use `findPoints0dim` if I is of dim 0 and has degree smaller than the
    -- size of the field k (or when char k = 0)
    -- if degree is large, the eliminant might not give much useful information
    -- but takes a long time to compute
    if dimI == 0 and (char k == 0 or degI < #els) then return findPoints0dim(I, Amount=>opts.Amount);
    -- otherwise, enumerate the possible values
    possibleValues := els;
    pols := select(first entries gens I, p->(p!=0));
    univarPols := pols;
    if n > 1 then (
        univarPols = select(pols, p->(support p == {x_0}));
    );
    if #univarPols > 0 then (
        pol := univarPols_0;
        -- factor the first polynomial to find its roots
        coeffs := apply((degree pol)_0+1, i->coefficient(x_0^i, pol));
        possibleValues = zeros coeffs;
        for p in univarPols_{1..<#univarPols} do ( -- keep only the common roots
            eval := v->sum((degree p)_0+1, i->coefficient(x_0^i, p)*product toList(i:v));
            possibleValues = select(possibleValues, v->(eval v == 0));
        );
    );
    if n == 1 then (
        if opts.Amount then return #possibleValues
        else return (v->{v}) \ possibleValues;
    ) else (
        R' := rings_(n-1);
        x = gens R';
        result = if opts.Amount then 0 else {};
        for v in possibleValues do (
            I' := (map(R', R, {v}|x)) I;
            if degree I' > 0 then (
                if opts.Amount then result = result + findPoints(I', Amount=>true)
                else result = result | (x->{v}|x) \ findPoints(I', Amount=>false);
            );
            -- when dim I = 0, there are at most degI points
            if dimI == 0 and (if opts.Amount then result else #result) == degI then break;
        );
        return result;
    );
);
-------------------------------------------------------------------------------
-- the following is based on https://www.math.tamu.edu/~sottile/research/ps/realroots.m2
-- written by Dan Grayson & Frank Sottile
-- computes the eliminant (up to multiplicity) of an element h in a zero
-- dimension ring A=R/I
-- takes in an element h and a univariate polynomial ring S
-- returns the characteristic polynomial of the action of h on A, as an element
-- of S
--
charPoly = (h, S) -> (
    A := ring h;
    assert(dim A == 0);
    b := basis A;
    k := coefficientRing A;
    getConst := M -> matrix \\ (row->(row / coefficient_(1_A))) \ entries M;
    Mh := getConst contract(transpose b, h*b);
    return det(S_0 - Mh ** S);
);
-------------------------------------------------------------------------------
-- `findPoints` for 0-dimensional ideals
-- computes and solves the eliminant to get a list of possible values for the
-- current coordinate
--
findPoints0dim = method(Options => {Amount=>false});
findPoints0dim(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    -- using the eliminant to find the possible values
    S := rings_1;
    g := charPoly(sub(x_0, R/I), S);
    coeffs := apply((degree g)_0+1, i->coefficient(S_0^i, g));
    possibleValues := zeros coeffs;
    R' := rings_(n-1);
    x = gens R';
    if n == 1 then (
        if opts.Amount then return #possibleValues
        else return (v->{v}) \ possibleValues;
    ) else (
        result := if opts.Amount then 0 else {};
        for v in possibleValues do (
            I' := (map(R', R, {v}|x)) I;
            if degree I' == 1 then ( -- for a single point `linearSolve` is faster
                if opts.Amount then result = result + 1
                else result = result | (x->{v}|x) \ linearSolve I';
            ) else (
                if opts.Amount then result = result + findPoints0dim(I', Amount=>true)
                else result = result | (x->{v}|x) \ findPoints0dim(I', Amount=>false);
            );
        );
        return result;
    );
);
-------------------------------------------------------------------------------
-- takes in a homogeneous ideal and enumerate points in the projective space
--
findProjPoints = method(Options => {Amount=>false});
findProjPoints(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    result := if opts.Amount then 0 else {};
    -- find all rational points of form (1,...), (0,1,...), (0,0,1,...) etc.
    for i in (1..n) do (
        R' := rings_(n-i);
        x = gens R';
        v := toList((i-1):0_k)|{1_k};
        I' := (map(R', R, v|x)) I;
        if degree I' > 0 then (
            if opts.Amount then result = result + findPoints(I', Amount=>true)
            else result = result | (x->v|x) \ findPoints(I', Amount=>false);
        );
    );
    return result;
);
-------------------------------------------------------------------------------
-- main interface
-------------------------------------------------------------------------------
-- takes in an ideal
-- pre-processing: `mingens` the ideal and reorder the variables
-- enumeration of the points
-- post-processing: reconstruct the points according to the original order
-- returns the list of points or the number of points if `Amount` is set to
-- true
--
rationalPoints = method(Options => {Projective=>false, Amount=>false});
rationalPoints(Ideal) := opts -> I -> (
    R := ring I;
    if not isPolynomialRing R then error "expect a polynomial ring"; -- sanity check
    k := coefficientRing R;
    if not isField k then error "the coefficient ring is not a field"; -- sanity check
    if char k > 0 then els = listFieldElements k;
    x := gens R;
    n := #x;
    rings = (0..n) / (i->k(monoid[x_{0..<i}])); -- predefine the polynomial rings
    I = ideal mingens I;
    dimI := dim I;
    if dimI < 0 then return if opts.Amount then 0 else {}; -- trivial case
    --
    -- the number field case
    if char k == 0 then (
        if (not opts.Projective and dimI > 0) or (opts.Projective and dimI > 1)
        then error "over number fields, positive dimension ideals are not implemented"
        else if opts.Projective then return findProjPoints(I, Amount=>opts.Amount)
        else return findPoints0dim(I, Amount=>opts.Amount);
    );
    --
    -- the finite field case
    -- we now get rid of the unused variables; they will be added at the end
    supp := set flatten(for p in first entries gens I list support p);
    ind := apply(n, i -> if member(x_i, supp) then 1 else 0);
    unused := n - sum ind;
    if unused > 0 then (
        R = rings_(n - unused);
        x = gens R;
        I = (map(R, ring I, shuffle(ind, (unused:0), x))) I;
    );
    -- enumeration of points and post-processing
    result := null;
    if opts.Projective then ( -- projective case
        if not isHomogeneous I then error "not a homogeneous ideal"; -- sanity check
        result = findProjPoints(I, Amount=>opts.Amount);
        if unused > 0 then ( -- reconstruction
            if opts.Amount then result = result*(#els)^unused+((#els)^unused-1)//(#els-1)
            else (
                -- shuffle and homogenize so that the first non-zero coordinate is 1
                result = flatten table(pow_unused els, result, homoCoord @@ shuffle_ind);
                -- extra points lying in a projective subspace
                PP := findProjPoints(ideal 0_(rings_unused));
                result = result | PP / (x->homoCoord shuffle(ind, x, ((n-unused):0_k)));
            );
        );
    ) else ( -- affine case
        result = findPoints(I, Amount=>opts.Amount);
        if unused > 0 then ( -- reconstruction
            if opts.Amount then result = result*(#els)^unused
            else result = flatten table(pow_unused els, result, shuffle_ind);
        );
    );
    return result;
);
-------------------------------------------------------------------------------
-- the interface to specify an extension field
--
rationalPoints(Ring, Ideal) := opts -> (k, I) -> (
    if isField k then (
        R := ring I;
        if not isPolynomialRing R then error "expect a polynomial ring"; -- sanity check
        k0 := coefficientRing R;
        if char k0 != char k then error "different characteristics";
        -- TODO how to correctly do a field extension?
        if char k0 > 0 and not (isFinitePrimeField k0 or instance(k0, GaloisField) and k0.degree ==1)
        then error "base field not prime";
        if char k0 == 0 and k0 =!= QQ then error "base field not prime";
        x := gens R;
        I = sub(I, k(monoid[x]));
        return rationalPoints(I, Amount=>opts.Amount, Projective=>opts.Projective);
    ) else error "expect a field";
);
-------------------------------------------------------------------------------
rationalPoints(AffineVariety) := opts -> X -> (
    return rationalPoints(ideal X, Amount=>opts.Amount);
);
-------------------------------------------------------------------------------
rationalPoints(Ring, AffineVariety) := opts -> (k, X) -> (
    return rationalPoints(k, ideal X, Amount=>opts.Amount);
);
-------------------------------------------------------------------------------
rationalPoints(ProjectiveVariety) := opts -> X -> (
    return rationalPoints(ideal X, Amount=>opts.Amount, Projective=>true);
);
-------------------------------------------------------------------------------
rationalPoints(Ring, ProjectiveVariety) := opts -> (k, X) -> (
    return rationalPoints(k, ideal X, Amount=>opts.Amount, Projective=>true);
);
-------------------------------------------------------------------------------
beginDocumentation()
-------------------------------------------------------------------------------
document ///
Key
    RationalPoints2
Headline
    Find the rational points on a variety
Description
    Text
        {\em RationalPoints2} is a package for enumerating the rational points
        on a variety defined by an ideal of a polynomial ring. Over a finite
        field the ideal can be arbitrary; over a number field the ideal must be
        of dimension 0. The coefficient field can also be specified.
///
-------------------------------------------------------------------------------
doc ///
Key
    rationalPoints
    (rationalPoints, Ideal)
    (rationalPoints, AffineVariety)
    (rationalPoints, ProjectiveVariety)
    (rationalPoints, Ring, Ideal)
    (rationalPoints, Ring, AffineVariety)
    (rationalPoints, Ring, ProjectiveVariety)
    Amount
    Projective
    [rationalPoints,Amount]
    [rationalPoints,Projective]
Headline
    Find the rational points on a variety
Usage
    rationalPoints I
    rationalPoints(F, I)
Inputs
    I:Ideal
        viewed as an affine variety; @ofClass AffineVariety@ / @ofClass
        ProjectiveVariety@ can also be used
    F:Ring
        the coefficient field; if not specified then it is taken to be the
        field of definition of {\tt I}, otherwise {\tt I} must be defined over
        the prime field of {\tt F}
    Amount=>Boolean
        whether to only compute the number of rational points.
    Projective=>Boolean
        whether to treat the ideal as a homogeneous ideal and consider the
        corresponding projective variety
Outputs
    :
        Either @ofClass List@ of points, each represented by @ofClass List@
        of coordinates, or the number of such points if {\tt Amount} is set
        to true
Description
    Text
        Return a list of rational points contained in the affine variety given
        by the input ideal {\tt I}. Over a finite field ({\tt ZZ/p} or {\tt GF
        q}), the ideal can have arbitrary dimension.
    Example
        R = ZZ/5[x,y,z];
        I = ideal(x^3-y*z, x+y);
        rationalPoints I
        rationalPoints(Spec(R/I), Amount=>true)
        #rationalPoints_(GF 25) I
    Text
        Over a number field the ideal must be of dimension 0.
    Example
        R = QQ[x,y];
        I = ideal(x^2+y^2-1,x^3+y^3-1);
        rationalPoints I
        F = toField(QQ[q]/(q^2+2));
        rationalPoints_F I
    Text
        If a projective variety is considered, the rational points are given in
        homogeneous coordinates. The first non-zero coordinate will be
        normalized to 1.
    Text
        For example we can take the twisted cubic, which is a smooth rational
        curve so it has q+1 points over a finite field of q elements.
    Example
        R = ZZ/5[x,y,z,w];
        I = ideal "xz-y2,xw-yz,yw-z2";
        rationalPoints(I, Projective => true)
        #rationalPoints variety I
        #rationalPoints_(GF 25) variety I
    Text
        Another nice example is the 27 lines on the Fermat cubic surface. Note
        that only 3 of them are defined over the rational numbers.
    Example
        R = QQ[a,b,c,d];
        I = ideal(a^3+b^3+c^3+d^3);
        #rationalPoints variety Fano_1 I
        F = toField(QQ[w]/(w^2+w+1));
        #rationalPoints_F variety Fano_1 I
    Text
        If only the number of rational points is needed, set {\tt Amount} to
        {\tt true} can sometimes speed up the computation.
    Example
        R = ZZ/101[u_0..u_10];
        f = sum toList(u_0..u_10);
        I = ideal f
        time rationalPoints(I, Amount => true)
    Text
        This symbol is provided by the package @TO RationalPoints2@.
///
-------------------------------------------------------------------------------
TEST ///
    R = ZZ/13[a];
    assert(#rationalPoints ideal(0_R) == 13);
    assert(#rationalPoints ideal(1_R) == 0);
    assert(#rationalPoints ideal(a-2) == 1);
    R = ZZ/5[x_1..x_4];
    I = ideal(x_2^2+x_1*x_2+1, x_1*x_2*x_3*x_4+1);
    assert(#rationalPoints I == 8);
    k = GF 9;
    R = k[m,n,j];
    I = ideal(m+1, n*j);
    assert(rationalPoints(I,Amount => true) == 17);
    R = ZZ/13[b,c,d];
    I = ideal (0_R);
    assert(rationalPoints(I,Amount => true) == 2197);
    R = QQ[x];
    I = ideal (x^2*(x+1)*(x^2-2));
    assert(rationalPoints(I,Amount => true) == 2);
///
-------------------------------------------------------------------------------
TEST ///
    assert(#rationalPoints Grassmannian(1,3,CoefficientRing=>ZZ/2) == 36);
    R = ZZ/101[u_0..u_10];
    I = ideal sum toList(u_0..u_10);
    assert(rationalPoints(I, Amount => true) == 101^10);
    R = ZZ/101[x,y,z];
    I = homogenize(ideal(y^2-x^3-x^2), z);
    assert(#rationalPoints variety I == 101);
    R = QQ[x,y];
    I = ideal(x^2+y^2-1,x^3+y^3-1);
    F = toField(QQ[q]/(q^2+2));
    assert(#rationalPoints_F I == 4);
///
-------------------------------------------------------------------------------
TEST ///
    R = QQ[a,b,c,d];
    I = ideal(a^3+b^3+c^3+d^3);
    F' = toField(QQ[w]/(w^2+w+1));
    assert(#rationalPoints_F' variety Fano_1 I == 27);
///
-------------------------------------------------------------------------------
TEST ///
    needsPackage "Points";
    k = ZZ/101; (m, n) = (10, 2); R = k[x_1..x_n];
    M = random(k^n, k^m);
    mul = toList(1..m) / (i->random(1, 3));
    I = ideal last affineFatPoints(M, mul, R);
    S1 = entries transpose M;
    S2 = rationalPoints I;
    assert(set S1 === set S2);
///
-------------------------------------------------------------------------------
TEST ///
    F = ZZ/67; S = F[x_0..x_9];
    sigma0 = {(0,2,5),(1,3,6),(2,4,7),(3,0,8),(4,1,9),(0,9,7),(1,5,8),(2,6,9),(3,7,5),(4,8,6)};
    delta = (x,y,v) -> table(10,10,(i,j) -> if i==x and j==y then v else 0);
    skew = (i,j,k) -> sum(delta \ {(i,j,x_k),(j,k,x_i),(k,i,x_j),(j,i,-x_k),(k,j,-x_i),(i,k,-x_j)});
    I = trim pfaffians_6 matrix sum(skew \ sigma0);
    assert(#rationalPoints variety I == 55);
///
-------------------------------------------------------------------------------
endPackage "RationalPoints2"
-------------------------------------------------------------------------------
