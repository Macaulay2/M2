-------------------------------------------------------------------------------
-- licensed under GPL v2 or any later version
-------------------------------------------------------------------------------
newPackage(
    "RationalPoints2",
    Version => "0.2",
    Date => "Jan 23, 2021",
    Authors => { {Name => "Jieao Song", Email => "jieao.song@imj-prg.fr"} },
    Headline => "find the common zeros for a set of polynomials over a finite field",
    Keywords => {"Commutative Algebra"},
    DebuggingMode => false
)
-------------------------------------------------------------------------------
-- This program takes in an ideal generated by a list of polynomials with
-- coefficients in a finite field. It finds all of the common zeroes of the
-- polynomials (over the coefficient field) and returns them.
-------------------------------------------------------------------------------
-- The algorithm naively tests points coordinate by coordinate. There are
-- however several tricks used to improve the performance.
--
-- * If at some coordinate we encounter some univariate polynomials, we test
-- only with their common roots instead of using the entire field k.
--
-- * If we get a prime ideal of degree 1, we solve a linear system of equations
-- to quickly get all the points contained in the corresponding linear
-- subspace.
--
-- * If the ideal is homogeneous, we will enumerate the rational points in the
-- projective space first, then reconstruct the points in the affine space;
-- this can also be done recursively.
--
-- * If the ideal is 0-dimensional and has relative small degree, we use
-- the eliminant to solve the system.
-------------------------------------------------------------------------------
export{"rationalPoints", "Amount"}
-------------------------------------------------------------------------------
-- rings: a list of polynomial rings in increasing variable numbers
-- i.e. {k[], k[x], k[x,y], ...}
local rings;
-- els: a list of elements in the finite field k
local els;
-------------------------------------------------------------------------------
-- takes in a finite field and returns the list of its elements
--
fieldElements = (k) -> (
    if isFinitePrimeField k then (return apply(char k, i->i*1_k););
    if not instance(k, GaloisField) then try k = GF k;
    if instance(k, GaloisField) then (
        x := k.PrimitiveElement;
        p := k.char;
        d := k.degree;
        return {0_k}|(for e in (1..<p^d) list x^e*1_k);
    ) else error "fieldElements: not a finite field";
);
-------------------------------------------------------------------------------
-- takes a number n and a list
-- produces the direct product of the list with itself n times
-- same as lst**lst**lst**... but with flattened elements
--
pow = (n, lst) -> (
    if n < 0 then error "power of a list is not defined for n negative";
    result := {{}};
    for i in (0..<n) do result = flatten \ (result ** lst);
    return result;
);
-------------------------------------------------------------------------------
-- utility function that shuffles two list u and v according to a list ind
-- of indices in 0 (for u) and 1 (for v)
--
shuffle = (ind, u, v) -> (
    (i,j) := (-1,-1);
    return for k in (0..<#ind) list if ind_k==0 then (i=i+1; u_i) else (j=j+1; v_j);
);
-------------------------------------------------------------------------------
-- takes in a list of coefficients representing a univariate polynomial
-- returns the list of zeros
-- e.g. {2,-3,1} -> 2-3*x+x^2 which returns {1, 2}
--
zeros := (coeffs) -> (
    R := rings_1;
    y := (gens R)_0;
    p := sum apply(#coeffs, i->coeffs_i*y^i);
    factors := toList select(factor p, c->(degree value first c == {1}));
    getValue := c -> -coefficient(1_R, c)/coefficient(y, c);
    return getValue \ value \ first \ factors;
);
zeros = memoize zeros;
-------------------------------------------------------------------------------
-- takes in a linear ideal and returns the list of solutions
--
linearSolve := (I) -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    system := first entries gens gb I;
    if system == {} then return pow_n els;
    -- solve a system of linear equations Ax=b
    A := matrix apply(system, f->apply(x, xi->coefficient(xi, f)));
    b := matrix apply(system, f->{-coefficient(1_R, f)});
    v := transpose solve(A,b);
    if #system == n then return {first entries v};
    M := transpose gens kernel A;
    getSolution := x -> first entries (v+matrix{toList x}*M);
    return getSolution \ pow_(n-#system) els;
);
linearSolve = memoize linearSolve;
-------------------------------------------------------------------------------
-- utility function that normalizes a list of homogeneous coordinates so that
-- the first non-zero coordinate is 1
--
homoCoord = p -> (a := p_(position(p, x->(x!=0))); (x->x/a) \ p);
-------------------------------------------------------------------------------
-- the main function that carries out the enumeration of points
-- takes in an ideal and enumerate the points coordinate by coordinate
-- returns the list of points or the number of points if Amount is set to true
--
-- the ideal is ALWAYS assumed to be non-trivial, i.e. not (1)
--
findPoints = method(Options => {Amount=>false});
findPoints(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    result := null;
    (dimI, degI) := (dim I, degree I);
    -- use linearSolve if I is linear
    if degI == 1 and (dimI == 0 or isPrime I) then (
        if opts.Amount then return (#els)^(dimI)
        else return linearSolve I;
    );
    -- use findProjPoints if I is homogeneous
    if isHomogeneous I then (
        result = findProjPoints(I, Amount=>opts.Amount);
        if opts.Amount then return 1+(#els-1)*result
        else return {toList(n:0_k)} | join flatten((v->(a->a*v)\els_{1..<#els}) \ result);
    );
    -- use findPoints0dim if I is of dim 0 and has degree smaller than the size
    -- of the field k
    -- if degree is large, the eliminant might not give much useful information
    -- but takes a long time to compute
    if dimI == 0 and degI < #els then return findPoints0dim(I, Amount=>opts.Amount);
    -- otherwise, enumerate the possible values
    possibleValues := els;
    pols := select(first entries gens I, p->(p!=0));
    univarPols := pols;
    if n > 1 then (
        univarPols = select(pols, p->(support p == {x_0}));
    );
    if #univarPols > 0 then (
        pol := univarPols_0;
        -- factor the first polynomial to find its roots
        coeffs := apply((degree pol)_0+1, i->coefficient(x_0^i, pol));
        possibleValues = zeros coeffs;
        for p in univarPols_{1..<#univarPols} do ( -- keep only the common roots
            eval := v->sum((degree p)_0+1, i->coefficient(x_0^i, p)*product toList(i:v));
            possibleValues = select(possibleValues, v->(eval v == 0));
        );
    );
    if n == 1 then (
        if opts.Amount then return #possibleValues
        else return (v->{v}) \ possibleValues;
    ) else (
        R' := rings_(n-1);
        x = gens R';
        result = if opts.Amount then 0 else {};
        for v in possibleValues do (
            I' := (map(R', R, {v}|x)) I;
            if degree I' > 0 then (
                if opts.Amount then result = result + findPoints(I', Amount=>true)
                else result = result | (x->{v}|x) \ findPoints(I', Amount=>false);
            );
            -- when dim I = 0, there are at most degI points
            if dimI == 0 and (if opts.Amount then result else #result) == degI then break;
        );
        return result;
    );
);
-------------------------------------------------------------------------------
-- the following is retrieved from https://www.math.tamu.edu/~sottile/research/ps/realroots.m2
-- written by Dan Grayson & Frank Sottile
-- computes the eliminant (up to multiplicity) of an element h in a zero
-- dimension ring A=R/I
-- takes in an element h and a univariate polynomial ring S
-- returns the eliminant as an element of S
--
regularRep = f -> (
    assert( dim ring f == 0 );
    b := basis ring f;
    k := coefficientRing ring f;
    return substitute(contract(transpose b, f*b), k);
);
charPoly = (h, S) -> (
    A := ring h;
    F := coefficientRing A;
    mh := regularRep h ** S;
    Idz := S_0 * id_(S^(numgens source mh));
    return det(Idz - mh);
);
-------------------------------------------------------------------------------
-- findPoints for 0-dimensional ideals
-- computes and solves the eliminant to get a list of possible values for the
-- current coordinate
--
findPoints0dim = method(Options => {Amount=>false});
findPoints0dim(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    -- using the eliminant to find the possible values
    S := rings_1;
    g := charPoly(sub(x_0, R/I), S);
    coeffs := apply((degree g)_0+1, i->coefficient(S_0^i, g));
    possibleValues := zeros coeffs;
    R' := rings_(n-1);
    x = gens R';
    result := if opts.Amount then 0 else {};
    for v in possibleValues do (
        I' := (map(R', R, {v}|x)) I;
        if degree I' == 1 then ( -- for a single point linearSolve is faster
            if opts.Amount then result = result + 1
            else result = result | (x->{v}|x) \ linearSolve I';
        ) else (
            if opts.Amount then result = result + findPoints0dim(I', Amount=>true)
            else result = result | (x->{v}|x) \ findPoints0dim(I', Amount=>false);
        );
    );
    return result;
);
-------------------------------------------------------------------------------
-- takes in a homogeneous ideal and enumerate points in the projective space
-- returns the list of points or the number of points if Amount is set to true
--
findProjPoints = method(Options => {Amount=>false});
findProjPoints(Ideal) := opts -> I -> (
    R := ring I;
    k := coefficientRing R;
    x := gens R;
    n := #x;
    result := if opts.Amount then 0 else {};
    -- find all rational points of form (1,...), (0,1,...), (0,0,1,...) etc.
    for i in (1..n) do (
        R' := rings_(n-i);
        x = gens R';
        v := toList((i-1):0_k)|{1_k};
        I' := (map(R', R, v|x)) I;
        if degree I' > 0 then (
            if opts.Amount then result = result + findPoints(I', Amount=>true)
            else result = result | (x->v|x) \ findPoints(I', Amount=>false);
        );
    );
    return result;
);
-------------------------------------------------------------------------------
-- main interface
-------------------------------------------------------------------------------
-- takes in an ideal
-- pre-processing: mingens the ideal and reorder the variables
-- enumeration of the points
-- post-processing: reconstruct the points according to the original order
-- returns the list of points or the number of points if Amount is set to true
--
rationalPoints = method(Options => {Projective=>false, Amount=>false});
rationalPoints(Ideal) := opts -> I -> (
    R := ring I;
    if not isPolynomialRing R then error "expect a polynomial ring"; -- sanity check
    k := coefficientRing R;
    try els = fieldElements k else error "the coefficient ring is not a finite field"; -- sanity check
    x := toList gens R;
    n := #x;
    rings = {k[]}|apply(n, i->k[x_{0..i}]); -- predefine the polynomial rings
    I = ideal mingens I;
    if dim I < 0 then return if opts.Amount then 0 else {}; -- trivial case
    -- we now get rid of the unused variables; they will be added at the end
    supp := set flatten(for p in first entries gens I list support p);
    ind := apply(n, i -> if member(x_i, supp) then 1 else 0);
    unused := n - sum ind;
    if unused > 0 then (
        R = rings_(n - unused);
        x = gens R;
        I = (map(R, ring I, shuffle(ind, (unused:0), x))) I;
    );
    -- enumeration of points and post-processing
    result := null;
    if opts.Projective then ( -- projective case
        if not isHomogeneous I then error "not a homogeneous ideal"; -- sanity check
        result = findProjPoints(I, Amount=>opts.Amount);
        if unused > 0 then ( -- reconstruction
            if opts.Amount then result = result*(#els)^unused+((#els)^unused-1)//(#els-1)
            else (
                -- shuffle and homogenize so that the first non-zero coordinate is 1
                result = flatten table(pow_unused els, result, homoCoord @@ shuffle_ind);
                -- extra points lying in a projective subspace
                result = result | (x->homoCoord shuffle(ind, x, ((n-unused):0_k))) \ findProjPoints(ideal 0_(rings_unused));
            );
        );
    ) else ( -- affine case
        result = findPoints(I, Amount=>opts.Amount);
        if unused > 0 then ( -- reconstruction
            if opts.Amount then result = result*(#els)^unused
            else result = flatten table(pow_unused els, result, shuffle_ind);
        );
    );
    return result;
);
-------------------------------------------------------------------------------
rationalPoints(AffineVariety) := opts -> X -> (
    return rationalPoints(ideal X, Amount=>opts.Amount);
);
-------------------------------------------------------------------------------
rationalPoints(ProjectiveVariety) := opts -> X -> (
    return rationalPoints(ideal X, Amount=>opts.Amount, Projective=>true);
);
-------------------------------------------------------------------------------
beginDocumentation()
-------------------------------------------------------------------------------
document {
    Key => RationalPoints2, Headline => "Find all the rational points on a
    variety defined over a finite field", EM "RationalPoints2", " is a package
    for enumerating the rational points on a variety defined over a finite
    field."
}
-------------------------------------------------------------------------------
doc ///
Key
    rationalPoints
    (rationalPoints, Ideal)
    (rationalPoints, AffineVariety)
    (rationalPoints, ProjectiveVariety)
    Amount
    Projective
    [rationalPoints,Amount]
    [rationalPoints,Projective]
Headline
    Find all the rational points on a variety defined over a finite field
Usage
    rationalPoints I
    rationalPoints X
Inputs
    I:Ideal
        viewed as an affine variety; @ofClass AffineVariety@ / @ofClass
        ProjectiveVariety@ can also be used
    Amount=>Boolean
        whether to only compute the number of rational points.
    Projective=>Boolean
        whether to treat the ideal as a homogeneous ideal and consider the
        corresponding projective variety
Outputs
    :
        Either @ofClass List@ of points, each represented by @ofClass List@
        of coordinates, or the number of such points if {\tt Amount} is set
        to true
Description
    Text
        Return a list of rational points contained in the affine variety given
        by the input ideal {\tt I}
    Example
        R = ZZ/5[x_1..x_4];
        I = ideal(x_2^2+x_1*x_2+1, x_1*x_2*x_3*x_4+1)
        rationalPoints I
        rationalPoints(Spec(R/I), Amount => true)
    Text
        If a projective variety is considered, the rational points are given in
        homogeneous coordinates. The first non-zero coordinate will be
        normalized to 1.
    Text
        For example, since a nodal cubic curve is the smooth rational curve
        glued along two points, it has exactly p points.
    Example
        R = ZZ/11[x,y,z];
        I = homogenize(ideal(y^2-x^3-x^2), z)
        rationalPoints(I, Projective => true)
        #rationalPoints variety I
    Text
        If only the number of rational points is needed, set {\tt Amount} to
        {\tt true} can speed up the computation.
    Example
        R = ZZ/101[u_0..u_10];
        f = sum toList(u_0..u_10);
        I = ideal f
        time rationalPoints(I, Amount => true)
    Text
        The algorithm detects reduced linear subspaces, so sometimes it might
        be helpful to pass the radical of the ideal (though the radical itself
        might take a long time to compute).
    Example
        time rationalPoints(radical ideal(f^2), Amount => true)
    Text
        This symbol is provided by the package @TO RationalPoints2@.
///
-------------------------------------------------------------------------------
TEST ///
    R = ZZ/13[a];
    assert(#rationalPoints ideal(0_R) == 13);
    assert(#rationalPoints ideal(1_R) == 0);
    assert(#rationalPoints ideal(a-2) == 1);
    R = ZZ/5[x_1..x_4];
    I = ideal(x_2^2+x_1*x_2+1, x_1*x_2*x_3*x_4+1);
    assert(#rationalPoints I == 8);
    k = GF 9;
    R = k[m,n,j];
    I = ideal(m+1, n*j);
    assert(rationalPoints(I,Amount => true) == 17);
    R = ZZ/13[b,c,d];
    I = ideal (0_R);
    assert(rationalPoints(I,Amount => true) == 2197);
///
-------------------------------------------------------------------------------
TEST ///
    assert(#rationalPoints Grassmannian(1,3,CoefficientRing=>ZZ/2) == 36);
    R = ZZ/101[u_0..u_10];
    I = ideal sum toList(u_0..u_10);
    assert(rationalPoints(I, Amount => true) == 101^10);
    R = ZZ/101[x,y,z];
    I = homogenize(ideal(y^2-x^3-x^2), z);
    assert(#rationalPoints variety I == 101);
///
-------------------------------------------------------------------------------
TEST ///
    F = ZZ/103;
    R = F[a,b,c,d];
    I = ideal"a3+b3+c3+d3";
    S = F[p_0..p_3,q_0..q_3];
    M = exteriorPower_2 matrix{{p_0..p_3},{q_0..q_3}};
    S' = F[s,t,p_0..p_3,q_0..q_3];
    f = map(S', R, s*matrix{{p_0..p_3}}+t*matrix{{q_0..q_3}});
    J = ideal sub(last coefficients(gens f I, Variables=>{s,t}), S);
    I = trim ker map(S/J, F[x_0..x_5], M);
    assert(#rationalPoints variety I == 27);
///
-------------------------------------------------------------------------------
TEST ///
    F = ZZ/67; S = F[x_0..x_9];
    sigma0 = {(0,2,5),(1,3,6),(2,4,7),(3,0,8),(4,1,9),(0,9,7),(1,5,8),(2,6,9),(3,7,5),(4,8,6)};
    delta = (x,y,v) -> table(10,10,(i,j) -> if i==x and j==y then v else 0);
    skew = (i,j,k) -> sum(delta \ {(i,j,x_k),(j,k,x_i),(k,i,x_j),(j,i,-x_k),(k,j,-x_i),(i,k,-x_j)});
    I = trim pfaffians_6 matrix sum(skew \ sigma0);
    assert(#rationalPoints variety I == 55);
///
-------------------------------------------------------------------------------
endPackage "RationalPoints2"
-------------------------------------------------------------------------------
