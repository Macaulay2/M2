COLLINO@dm.unito.it writes:
 > s  I have bee reading with interest your paper 
 > " bott's formula and enumerative geometry"
 >  I wander if the program you use is available
 > for the public, 
 > as you did with Schubert before.
 > 		I have been looking to the quartic 3-fold
 > case, and trying to imitate Beauville's work 
 > for the quantum cohomology 
 > it seems that I can get almost everything, by means
 > of previously known results, 
 > but at one point I need to find
 > the number of twisted cubics in the quartic 3-fold 
 > which meet a general plane and a general line in
 > P4, 
 > and this requires of course your computations.
 > If I am correct knowing this number 
 > would allow one to find some information
 > about quartic curves in the 3-fold, 
 > by means of the quantum cohomology circus.

Dear Collino,

sorry about the delay in responding to your request. Below you will
find first a Maple session computing the number that you ask for, and
then a Maple input file which contains the program and which is called
by the session. Note that the Schubert package is used by the code,
but not in a heavy-duty way. Unfortunately, the code is probably hard
to read, and has not been satisfactorily documented, but hopefully it
can be useful for you. You probably understand the meaning of the
classes s1, s2, s3 in the code (meet given plane, line, point). a413
means the 13-th Chern class of the bundle of quartics on the universal
twisted cubic curve over the Hilbert scheme component, hence a413
represents the 3-dimensional cycle of twisted cubics on a quartic
threefold. 

Let me know if the numbers are consistent with what you're doing!

Best regards,
Stein Arild Stromme

    |\^/|     Maple V Release 3 (BERGEN UNIVERSITY)
._|\|   |/|_. Copyright (c) 1981-1994 by Waterloo Maple Software and the
 \  MAPLE  /  University of Waterloo. All rights reserved. Maple and Maple V
 <____ ____>  are registered trademarks of Waterloo Maple Software.
      |       Type ? for help.
See ?share and ?share,contents for information about the share library
> read(twistedcubics):
dimension =   3   , maximal degree =   6
> Hilb(4);

                        currentvariety_ is H4, DIM is 16

> bott(a413*s1^3);  # cubics on quartic, meeting 3 planes

                                    8388608

> bott(a413*s1*s2); # cubics on quartic, meeting 1 plane and 1 line

                                     672768

> bott(a413*s3);    # cubics on quartic, meeting 1 point (of course)

                                       0

> quit;
bytes used=33191652, alloc=2948580, time=118.50

Process maple finished

Below follows the file "twistedcubics":

######################## cut here ##################################

## This file contains source code for computing the numbers in theorem
## 1.2 , as well as the formulas of 3.5 and 3.6. Note that the
## schubert package is needed; it is available by anonymous ftp from 
## ftp.math.okstate.edu in pub/schubert. 

# Converted automatically from 5.2 to Release 3

with(schubert):
gc(0):

# Start by defining a few procedures that are convenient when 
# computing in the representation ring of a torus.

# setuptorus(n,m) sets up an (n+1)-dimensional torus with
# characters x0,...,xn. The representation ring is identified
# with the Laurent series ring Z[xi,1/xi, i=0..n]. The canonical
# representation sum(x.i,i=0..N) is denoted by V[1]. Its symmetric
# powers are denoted by V[k].

unprotect(W):

setuptorus:=proc(N,M) 
global  V, dualsubstring, variables, ranksubstring;
local genf,i,k;
	genf:=expand(convert(series(
		1/product('1-x.i*t',i=0..N),t,M+1),polynom));
	for i from 0 to M do V[i]:=sort(coeff(genf,t,i)) od; i:='i';
	dualsubstring:=seq(x.i=x.i^(-1),i=0..N);
	variables    :=[seq(x.i,i=0..N),seq(x.i^(-1),i=0..N)];
	ranksubstring:=seq(x.i=1,i=0..N);
	lprint(`dimension =`,N,`, maximal degree =`,M);
end:

# dualrep(C) returns the dual representation, and
# Trank(C) returns the dimension of C

dualrep:=proc(C) sort(expand(subs(dualsubstring,C))) end:
Trank  :=proc(C) sort(expand(subs(ranksubstring,C))) end:

# A monomial ideal is represented formally by the sum of its 
# monomial generators in a given degree. Hence x0+x1 is the
# (linear part of the) ideal generated by x0 and x1.

# simpleweights(A) returns the sum of one-dimensional 
# representations, one for each occurring weight in A. For
# example, simpleweights(V[j]*V[k]) should return V[j+k].
# This is useful for computing twists of a monomial ideal:
# if I sub V[d], then simpleweights(I*V[1]) is the ideal I in 
# degree d+1.

simpleweights:=proc(p) local mon;
	expand(p); if p=0 then RETURN(0) fi;
	coeffs(",variables,'mon');
	convert([mon],`+`);
end:

# twistup(J,k) returns the ideal J in degree k higher.

twistup:=proc(J,k) simpleweights(J*V[k]) end:

# Usual operations in the representation ring are taken
# care of by standard algebraic operations like +, -, *
# in conjunction with dualrep. 

THom:=proc(A,B) sort(expand(dualrep(A)*B)) end:

# permut(elem,lis) is the action of a permutation "elem" 
# on a list "lis". The permutation is represented as a 
# product of disjoint cycles, as a list of lists. (As in
# the Maple "group" package).

permut:=proc(elem,ls)  local k,res,m,cyc,i,top;
res:=ls;
for m from 1 to nops(elem) do 
	cyc:=elem[m];
   top:=res[cyc[1]];
   for i from 1 to nops(cyc)-1 do
    res:=subsop(cyc[i]=res[cyc[i+1]],res)
   od;
  res:=subsop(cyc[i]=top,res):
od;
res
end:

# Let C^* -> T be the one-parameter subgroup given by weights 
# w0,w1,w2,w3. Thus the character xi restricts to t^(wi), i=0..3
# We need to find the all weights at each fixpoint.

weightlist:=proc(f) local t,cof,mon,res,i;
  cof:=[coeffs(f,variables,mon)];
  mon:=subs(x0=t^w0,x1=t^w1,x2=t^w2,x3=t^w3,[mon]);
  res:=NULL;
  for i from 1 to nops(mon) do 
    res:=res,subs(t=1,diff(mon[i],t))$cof[i] 
  od;
  res;
end:

# elsymlist(ls) returns the elementary symmetric polynomials in
# the elements of a sequence or list ls.

elsymlist:=proc() local res,gen,sbstr,a,rk,ls,T,k;
  if nargs=1 then ls:=op(args[1]) else ls:=args fi;
  rk:=nops([ls]);
  sbstr:=seq(a.k=ls[k],k=1..rk): k:='k':
  gen:=subs(sbstr,collect(expand(product('1+a.k*T',k=1..rk)),T));
  for k from 0 to rk do
    res[k]:=coeff(gen,T,k)
  od;
  op(res)
end:

###############################################################

# Start by studying the fixpoints in given P^3. We go up to degree
# 9 only because we want to compute the number of twisted cubics on
# a general degree 9 hypersurface in P^7. For the Calabi-Yau three-
# folds it would suffice with M=5.

M:=6: 
setuptorus(3,M);	

# The eight types of fixpoints:

# Cohen-Macaulay types 1--4, with tangent spaces and global sections:

EE[1]:=x0*x1+x1*x2+x2*x3: 
EE[2]:=x0*x1+x1*x2+x0*x2: 
EE[3]:=x0*x1+x2^2+x0*x2:  
EE[4]:=x0^2+x0*x1+x1^2:  
for i to 4 do 
  F[i]:=expand(EE[i]*V[1]-simpleweights(EE[i]*V[1])):
  TH[i]:=expand(THom(F[i],EE[i])*V[1]-THom(F[i],F[i])-THom(EE[i],EE[i])+1):
  OC[1,i]:=V[1]:
  for j from 2 to M do OC[j,i]:=V[j]-twistup(EE[i],j-2) od:
od:


# Non Cohen-Macaulay types 5--8, with tangent spaces and global sections:

beta:=expand(x0*(x0+x1+x2)):               # the same net "beta" of quadrics
q   :=[x1*x2*x3,x1*x2^2,x2^2*x3,x2^3]:     # four different cubic forms
TI  :=expand((x1+x2+x3)/x0+x3/x1+x3/x2):   # tangent space of I at beta
VF  :=subs(x0=0,twistup(x1^2+x1*x2+x2^2,1)):# singular cubics through x1=x2=0

for i from 5 to 8 do
  Id[i]  :=twistup(beta,1)+q[i-4]:         # ideal in degree 3
  TH[i]  :=TI+expand(VF/q[i-4]-1+q[i-4]/(x0*x1*x2)): # (formula (x.x))
  OC[1,i]:=V[1]:
  OC[2,i]:=V[2]-beta:		              
  for j from 3 to M do OC[j,i]:=V[j]-twistup(Id[i],j-3) od:
od:         

# Isotropy groups: the permutations of the variables x0,x1,x2,x3
# that leave each T-fixpoint fixed. Permutations are products of 
# disjoint cycles, all are sugroups of the symmetric group S4.

with(group):                                # use "group" package
isot[1]:=permgroup(4,{[[1,4],[2,3]]}):      # switch x0<->x3 and x1<->x2
isot[2]:=permgroup(4,{[[1,2]],[[1,2,3]]}):  # all perms of x0,x1,x2
isot[3]:=permgroup(4,{[]}):                 # no isotropy
isot[4]:=permgroup(4,{[[1,2]],[[3,4]]}):    # switch x0<->x1 or x2<->x3
isot[5]:=permgroup(4,{[[2,3]]}):            # symmetric in x1 and x2
isot[6]:=permgroup(4,{[]}):                 # no isotropy
isot[7]:=permgroup(4,{[]}):                 # no isotropy
isot[8]:=permgroup(4,{[]}):                 # no isotropy

# To generate all fixpoints, we move the 8 given ones with one 
# representatives for each coset of the isotropy group.

S4:=permgroup(4,{[[1,2]],[[1,2,3,4]]}):     # symmetric group on x0,x1,x2,x3
for i to 8 do orb[i]:=cosets(S4,isot[i]) od:# repr. modulo isotropy 

W:=w0,w1,w2,w3:                             # symbolic weights on P3

# tangent bundle, weight products for all 130 fixpoints:

for i from 1 to 8 do 
  tanlist[i]:=weightlist(TH[i]);
  den[i]:=unapply(convert(["],`*`),W) 
od:

k:=0:
for i to 8 do for j to nops(orb[i]) do
  k:=k+1;
  fixtan[k]:=unapply(den[i](op(permut(orb[i][j],[W]))),W);
od od;

# standard bundles, weight lists for all 130 fixpoints

for i from 1 to 8 do for j from 1 to M do
  EEE[j,i]:=unapply([weightlist(OC[j,i])],W);
od: od:  i:='i': j:='j':

k:=0:
for i to 8 do for j to nops(orb[i]) do
  k:=k+1;
  for jj from 1 to M do
    wl:=EEE[jj,i](op(permut(orb[i][j],[W])));
    SB.jj[k]:=unapply(wl,W);
    SB[jj,k]:=unapply(product(1+T*wl[ii],ii=1..3*jj+1),W);
  od:
od od;

#######################################################################
## The variety H3 of twisted cubics in P^3. All Chern classes of all
## the standard bundles E_{3,d}, d=1,...,M are considered.

variety(H3,dim=12):
WK:=4,11,17,32:
for k from 1 to 130 do
  H3[tangentweightproduct_][k]:=fixtan[k](WK);
  for j from 1 to M do
    expand(SB[j,k](WK));
    BB.j[k]:=[coeff(",T,ii)$ii=0..DIM];
  od 
od:
H3[numberoffixpoints_]:=130:
for k from 1 to 130 do
  H3[bottsubstring_][k]:=seq(seq(a.j.i=BB.j[k][i+1],i=1..DIM),j=1..M):
od: i:='i': j:='j':

########################################################################
## Hilb(N) constructs the space of twisted cubics in P^N (N>3), and
## the resulting variety object is denoted by H.N, a table of fixpoints
## and associated data for some standard vector bundles. For the standard
## bundles E_{N,d}, d=1,2,3,4, all Chern classes a.d.i are considered,
## for the E_{N,d}, d=5,...,M, only the top Chern class.

Hilb:=proc(N) 
global  P3;
local i,WG,genf,z,fours,PN,sstring,k,kk,kkk,
                     ii,lis,sb,P3sdone,C,fire,rest,TG,WK,j,BB;
   if N=3 then RETURN(setvariety(H3)) fi;
   variety(H.N,dim=4*N);
   WG:=4,11: for i to N-1 do WG:=WG,WG[i]+WG[i+1]+2*i od:
   H.N[numberoffixpoints_]:=binomial(N+1,4)*130:

   genf   :=expand(product('1+z.i*t','i'=1..N+1)):
   fours  :=convert(coeff(genf,t,4),list):   # products of 4 vars.
   PN     :=coeff(genf,t,N+1):               # product of all vars.
   sstring:=seq(z.i=i,i=1..N+1):             # vars. -> indices

   P3sdone:=0;
   for P3 in fours do                        # P3 represents 4 variables
      C:=PN/P3:                              # C is the remaining vars.
      fire:=subs(sstring,convert(P3,list)):  # just the indices of m
      rest:=subs(sstring,convert(C,list)):   # the remaining indices
      TG:=product(product(WG[fire[kkk]]-WG[rest[kk]],
                   kkk=1..4),kk=1..N-3):     # tangent space of Grass(3,N)
      WK:=seq(WG[fire[kkk]],kkk=1..4): kkk:='kkk':
      #lprint(fire,binomial(N+1,4)-P3sdone,status[2],time()): 
 
      for k from 1 to 130 do
        H.N[tangentweightproduct_][P3sdone*130+k]:=fixtan[k](WK)*TG;
        sb:=NULL;
        for j from 4 to N+1 do                # NB!
          lis:=SB.j[k](WK);
          sb:=#a.j.1=convert(lis,`+`),          # NB!
              a.j.(3*j+1)=convert(lis,`*`),sb;
        od; 
        for j from 2 to 4 do
          expand(SB[j,k](WK));
          sb:=sb,seq(a.j.ii=coeff(",T,ii),ii=1..2);
        od;
        sb:=sb,seq(a.1.ii=coeff(expand(SB[1,k](WK)),T,ii),ii=1..4):
        H.N[bottsubstring_][P3sdone*130+k]:=sb;
      od:
      P3sdone:=P3sdone+1:        
   od: 
   where();
end:

bott:=proc()
local X,c,k,summ,j;
    if nargs = 0 then RETURN(`usage: bott(c) or bott(X,c)`) fi;
    if nargs = 2 then X := args[1]; c := args[2]
    elif nargs = 1 then X := currentvariety_; c := args[1]
    else ERROR(`wrong number of arguments. Usage:`)
    fi;
    if X[kind_] = projectivebundle_ or X[kind_] = grassmannbundle_ then
        RETURN(bott(X[basevariety_],lowerstar(X[structuremorphism_],c)))
    fi;
    if not assigned(X[numberoffixpoints_]) then RETURN('procname(args)') fi;
    summ:=0;
    for k from 1 to X[numberoffixpoints_] do
       summ:=subs(X[bottsubstring_][k],c)/X[tangentweightproduct_][k]+summ;
#       lprint(k,summ,status[2],time()):
    od;
    summ
end:

# schubert code to find the class of the universal curve
# C sub P(V), where V is a rank-4 vector bundle on a generic base.

DIM:=2: # We are going for a codimension 2 class.

# The class [C] is to be expressed in the hyperplane class h and
# the Chern classes of the bundles B[i] = pr_* o_C(i) for i=1,2,3,4.
# It is clear that B[1]=V. The other Chern classes are given names
# a.i.j.

for i from 1 to 4 do B[i]:=bundle(3*i+1,a.i) od: i:='i':

# Use relative Beilinson on the coherent sheaf o_C(4):

omega1:=B[1]-o(h):
OC:=o(-4*h)&*sum('(-1)^i*B[4-i]&*wedge(i,omega1)',i=0..3):
Cclass:=collect(-chern(2,OC),h):

# Back to H3, make a projective bundle, corresponding to the
# variable linear span of the curve.

setvariety(H3):
B[1]:=bundle(4,a1):
Proj(psi,B[1],h):  
for i from 0 to 4 do 
   s.i:=lowerstar(psi,h^(i+1)*Cclass) 
od:

####################### end of setup ##########################

# To compute invariants for CY hypersurface in P4, P5, P6, uncomment
# the relevant line below

# Hilb(4); #bott(a516); 
# bott(a413*s1^3);          On quartic hypersurface in P4
# Hilb(5); bott(a619*s1);
# Hilb(6); bott(a722*s1^2); bott(a722*s2);

##########################
# For invariants of quartic hypersurface in P4:

#Hilb(4); bott(a413*s1^3);
################################################################

# To compute invariants for CY hypersurface in P7, uncomment these
# lines.

# Hilb(7);
# bott(a825*s1^3);
# bott(a825*s1*s2);
# bott(a825*s3);
################################################################

# To compute invariants for CY hypersurface in P8, uncomment these
# lines.

# Hilb(8);
# lprint(bott(1),status[2],time());
# lprint(bott(a928*s1^4),status[2],time());
# lprint(bott(a928*s1^2*s2),status[2],time());
# lprint(bott(a928*s1*s3),status[2],time());
# lprint(bott(a928*s2^2),status[2],time());
# lprint(bott(a928*s4),status[2],time());

# To compute invariants of quartic threefold, uncomment these lines:

# Hilb(4); 
# bott(a413*s1^3);  8388608 tw. cubics meeting three planes in P4
# bott(a413*s1*s2); 672768  tw. cubics meeting a plane and a line
# bott(a413*s3);    0       tw. cubics passing through a point (of course!)

###############################################################
#quit;

################## end of file #############################


