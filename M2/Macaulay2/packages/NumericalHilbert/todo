* Add sentence about J\I being large
* Don't need to remember old witness polynomials in the algorithm
* Distinguish how J_d != I_d is tested for truncation vs double truncation
* "suspect component"
* examples embedded (cyclic4 in sec 6.1, eliminating dual example in sec 4)
* Go through paper for notation/structure/clarity
* paper: polish the proofs for slicing down to dim 0
* straighten out appendix (Jon?)

* isComponentEmbedded (for dim > 0)
* keywords to allow options: "random", "isSubset", "quotient", "intersect", "add", "truncate"


--------------------------------
user-facing functions and types:
NumericalHilbert.m2
* truncatedDual
* zeroDimensionalDual
* gCorners
* sCorners
* localHilbertRegularity
* eliminatingDualSpace (eliminatingDualSpace)
* truncate (eliminatingDualSpace)

* TruncDualData
* truncDualData
* nextTDD
* homogPolySpace
* newGCorners

NAGtypes.m2
* PolySpace
* polySpace
* DualSpace
* dualSpace
* gens
* dim
* ring
* net
* origin (NumericalHilbert)

NPD file (name?)
* isPointEmbedded (isPointEmbedded)
* isPointEmbeddedInCurve (eliminatingDualSpace)
* doubleTruncation (isPointEmbedded)
* isWitnessPolynomial (isPointEmbedded)
* orthogonalInSubspace Ideal (isPointEmbedded)

numerical LA and DualSpace functionality (where should these go?)
* numericalKernel (NAGtypes)
* numericalImage (NAGtypes)
* colReduce (NAGtypes)

* addition (NAGtypes)
* intersection (NAGtypes)
* reduceSpace (NAGtypes)
* isContained (NAGtypes)
* areEqual (NAGtypes)
* hilbertFunction (NAGtypes)
* random (NAGtypes)
* orthogonalInSubspace (NumericalHilbert)
* innerProduct (NAGtypes)
* colon (NAGtypes)
