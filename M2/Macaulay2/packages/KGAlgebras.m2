newPackage(
    "KGAlgebras",
    Version => "0.5",
    Date => "February 19th, 2025",
    Authors => {
	{Name => "Daniel Koizumi", Email => "daniel.koizumi@utexas.edu"},
    {Name => "Moses Samuelson-Lynn", Email => "m.samuelsonlynn@utah.edu"},
    {Name => "Toshi Mowery", Email => "tosmow@gmail.com"}
    },
    Headline => "A package for KG-algebras",
    Keywords => {"KG-algebra"},
    DebuggingMode => true,
    Reload=>true,
    PackageExports=>{"AssociativeAlgebras","InvariantRing","RealRoots"}
    )
export {"KGAlg","meataxe", "SnGroup"}

KGAlgebra = new Type of FreeAlgebraQuotient;
KGAlg = method()
KGAlg (FiniteGroupAction, Ring) := (G,K) -> (
	if not isField K then (
		error "KGModules: Expected second argument to be a field.";
		);
	matrixElts := group G; -- create set of matrix elements
	n := #matrixElts-1; -- maximum index, since we are starting at 0
	groupIndices := {0..n}; -- indices
	g := symbol g;
	groupElts := g_0 .. g_n; -- group elements
	multTableIdealGens := {};
	FA := freeAlgebra(K,groupElts);
	use FA; -- make FA our working ring
	local H;
	local productInv;
	local multTableIdealGens;
	for i in 0 .. n do(
		for j in 0 .. n do( 
			productInv = position(matrixElts,M -> M==matrixElts#i * matrixElts#j);
			H= (FA_i)*(FA_j)-(FA_productInv);
			multTableIdealGens=append(multTableIdealGens,H);
		);
	);
	FA/ideal(multTableIdealGens) -- output
);
random(FreeAlgebraQuotient) := opt -> (S) -> (       
	randelt := sum(apply(toList(0 .. #(gens S)-1), i -> random(coefficientRing S) * S_i))
);
--True implies irreducible, false implies reducible
meataxe = method()
meataxe(FiniteGroupAction, FreeAlgebraQuotient,Ring) := (G,S,K) -> (
	local p;
	local L;
	local M;
	local MP;
	local y;
	local m;
	local q;
	local Mp;
	local M1;
	local MPP;
	local H;
	local N;
	local n;
	local M2;
	local NP;
	local yp;	
	while true do(
		--Do the meataxe algorithm 
		p = random S; --generate random element of KG algebra
		L = toList coefficients p;  
		M = (group G)#0-(group G)#0; -- zero matrix which has the same dimensions as an element of G
		m = 0;
		for x in (flatten entries L#0) do(
			n = index(x);
			M = M + (group G)#n * sub((flatten entries L#1)#m,K);
			m= m+1	
		); --This for loop generates a matrix representing p using the matrix elements for G
		--Factors of the characteristic polynomial of M
		q=apply(factor characteristicPolynomial M, y-> value y); --Get an array containing the factors of the characteristic polynomial of the matrix M
		q=sort toList q; --Sorts q by degree
		if (degree q#0)#0 == 0 then(
			q=drop(q,1)--Drops constant factor if possible
		);
		
		Mp = (group G)#0-(group G)#0; --zero matrix same dimensions as elements of G
		
		for P in q do( 
			n = (degree P)#0; 
			MP= Mp = (group G)#0-(group G)#0; 
			
			--Evaluates P on the matrix M
			for m in 0 .. #apply(apply((entries (coefficients P)#0)#0,degree),x-> x#0)-1 do(
				Mp=M^((apply(apply((entries (coefficients P)#0)#0,degree),x-> x#0))#m);
				Mp=Mp*(apply((entries (coefficients P)#1),x-> x#0))#m;
				MP = MP+Mp
			);
			

			--MP is p(theta) in the algorithm
			N = kernel MP;
			y= (gens N)_0;--Takes a "random" element of the kernel
			M1 = matrix apply(group G, z-> z*y); --multiplies all group elements by the random element, giving column vectors, and we make a matrix M1 from those vectors
			if rank M1 != rank ((group G)#0) then (
				return false;
			);--Checks that the module generated by M1 is not a strict submodule of KG
			
			H = apply(group G, z -> transpose(z)); --Generate list of group elements' matrices but transposed
			MPP = transpose MP;
			NP = kernel MPP;
			yp = (gens NP)_0;
			M2 = matrix apply(H,z -> z*yp);
			print(rank M2);
			if rank M2 != rank (H#0) then (
				return false;
			);
			if dim N == (degree(P))#0 then (
                                return true;
                        );
                        
		);
	);
);

-- symmetric groups
SnGroup = method(Options => {"K" => QQ})
SnGroup (ZZ) := opts -> (n) -> (
	xx := symbol xx;
	R := (opts#"K")[xx_1 .. xx_n]; -- polynomial ring to do the group action on
	cycle := new Array from 1 .. n; -- an n-cycle
        finiteAction({permutationMatrix(n, cycle), -- the cycle
			permutationMatrix(n, [1,2])}, -- a transposition
			R)
);






beginDocumentation()

doc ///
	Key
		KGAlgebras
	Headline
		A package for KG-algebras
	Description
		Text
			Implements KG-algebras and the meataxe algorithm to compute the irreducibility of a finite dimensional representation over a finite field.

///
doc ///
	Key
		KGAlg
	Headline
		Constructor for KGAlgebras
	Usage
		KGAlg(G,K)
	Inputs
		G:
			A FiniteGroupAction specifying a group.
		K:
			A field. 
	Outputs
		:
			A KG Algebra defined by group G and field K. 
	Description
		Text
			Takes a FiniteGroupAction G and a field K and creates a KG algebra KG from them. 
		Example
			R = QQ[x1,x2,x3];
			L = {matrix {{0,1,0},{1,0,0},{0,0,1}}, matrix {{0,0,1},{0,1,0},{1,0,0}}, matrix {{1,0,0},{0,0,1},{0,1,0}} };
			G = finiteAction(L,R);
			KGAlg(G,QQ)
///
doc ///
	Key
		meataxe		
	Headline
		Boolean function implementing the meataxe algorithm. 
	Usage
		T = meataxe(G,S,K)
	Inputs
		G:FiniteGroupAction
			A finite group action
		S:FreeAlgebraQuotient
			A KG-algebra
		K:Ring
			The underlying field of the other parameters.
	Outputs
		T:Boolean
			Returns true if the Meataxe algorithm states that the KG-module is irreducible. Returns false if the module is reducible. 
///
TEST ///
	K = ZZ/3
	R = ZZ/3[x1,x2];
	L= {matrix {{0,1},{1,0}},matrix {{2,0},{0,1}},matrix {{0,1},{2,0}},matrix {{1,0},{0,1}}};
	G = finiteAction(L,R);
	KG = KGAlg(G,K);
	assert ( meataxe(G,KG,K) == true );
///
TEST ///
	K = ZZ/3
        R = K[x1,x2,x3,x4];
        L = {matrix {{0,1,0,0},{1,0,0,0},{0,0,1,0},{0,0,0,1}}, matrix {{1,0,0,0},{0,1,0,0},{0,0,0,1},{0,0,1,0}}};
        G = finiteAction(L,R);
        KG = KGAlg(G,K);
        assert ( meataxe(G,KG,K) == false );
///

end--
