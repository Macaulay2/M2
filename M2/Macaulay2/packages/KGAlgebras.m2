newPackage(
    "KGAlgebras",
    Version => "0.5",
    Date => "February 19th, 2025",
    Authors => {
    {Name => "Daniel Koizumi", Email => "daniel.koizumi@utexas.edu"},
    {Name => "Moses Samuelson-Lynn", Email => "m.samuelsonlynn@utah.edu"},
    {Name => "Toshi Mowery", Email => "tosmow@gmail.com"}
    },
    Headline => "A package for group algebras",
    Keywords => {"Group Theory"},
    DebuggingMode => true,
    PackageExports=>{"AssociativeAlgebras","InvariantRing","RealRoots"}
    )
export {"GroupRing","groupRing","meataxe", "SnGroup"}

GroupRing = new Type of FreeAlgebraQuotient;
groupRing = method()
groupRing (FiniteGroupAction, Ring) := (G,K) -> (
    if not isField K then (
        error "KGModules: Expected second argument to be a field.";
    );
    matrixElts := group G; -- create set of matrix elements
    n := #matrixElts-1; -- maximum index, since we are starting at 0
    groupIndices := {0..n}; -- indices
    g := symbol g;
    groupElts := g_0 .. g_n; -- group elements
    FA := freeAlgebra(K,groupElts);
    use FA; -- make FA our working ring
    multTableIdealGens := new MutableList;
    for i in 0 .. n do(
        for j in 0 .. n do( 
            productInv := position(matrixElts,M -> M==matrixElts#i * matrixElts#j);
            H := (FA_i)*(FA_j)-(FA_productInv);
            multTableIdealGens##multTableIdealGens = H;
        );
    );
    print multTableIdealGens;
    FA/ideal(toList multTableIdealGens) -- output
);
random(FreeAlgebraQuotient) := opt -> (S) -> (       
    randelt := sum(apply(toList(0 .. #(gens S)-1), i -> random(coefficientRing S) * S_i))
);
--True implies irreducible. Otherwise returns proper K[G]-submodule. 
meataxe = method()
meataxe(FiniteGroupAction, FreeAlgebraQuotient,Ring) := (G,S,K) -> (
    while true do(
        --Do the meataxe algorithm 
        p := random S; --generate random element of KG algebra
        L := toList coefficients p;  
        M := (group G)#0-(group G)#0; -- zero matrix which has the same dimensions as an element of G
        m := 0;
        for x in (flatten entries L#0) do(
            n := index(x);
            M = M + (group G)#n * sub((flatten entries L#1)#m,K);
            m = m+1    
        ); --This for loop generates a matrix representing p using the matrix elements for G
        --Factors of the characteristic polynomial of M
        q := apply(factor characteristicPolynomial M, y-> value y); --Get an array containing the factors of the characteristic polynomial of the matrix M
        q = sort toList q; --Sorts q by degree
        if (degree q#0)#0 == 0 then(
            q = drop(q,1)--Drops constant factor if possible
        );
        
        Mp := (group G)#0-(group G)#0; --zero matrix same dimensions as elements of G
        
        for P in q do( 
            n := (degree P)#0; 
            MP := Mp = (group G)#0-(group G)#0; 
            
            --Evaluates P on the matrix M
            for m in 0 .. #apply(apply((entries (coefficients P)#0)#0,degree),x-> x#0)-1 do(
                Mp=M^((apply(apply((entries (coefficients P)#0)#0,degree),x-> x#0))#m);
                Mp=Mp*(apply((entries (coefficients P)#1),x-> x#0))#m;
                MP = MP+Mp
            );
            

            --MP is p(theta) in the algorithm
            N := kernel MP;
            y := (gens N)_0;--Takes a "random" element of the kernel
            M1 := matrix apply(group G, z-> z*y); --multiplies all group elements by the random element, giving column vectors, and we make a matrix M1 from those vectors
            if rank M1 != rank ((group G)#0) then (
                return image M1;
            );--Checks that the module generated by M1 is not a strict submodule of KG
            
            H := apply(group G, transpose); --Generate list of group elements' matrices but transposed
            MPP := transpose MP;
            NP := kernel MPP;
            yp := (gens NP)_0;
            M2 := matrix apply(H,z -> z*yp);
            if debugLevel == 1 then (
                print(rank M2);
            );
            if rank M2 != rank (H#0) then (
                return image M2;
            );
            if dim N == (degree(P))#0 then (
                                return true;
                        );
                        
        );
    );
);

-- symmetric groups
SnGroup = method(Options => {"K" => QQ})
SnGroup (ZZ) := opts -> (n) -> (
    xx := symbol xx;
    R := (opts#"K")[xx_1 .. xx_n]; -- polynomial ring to do the group action on
    cycle := new Array from 1 .. n; -- an n-cycle
        finiteAction({permutationMatrix(n, cycle), -- the cycle
            permutationMatrix(n, [1,2])}, -- a transposition
            R)
);






beginDocumentation()

doc ///
    Key
        KGAlgebras
    Headline
        A package for group rings
    Description
        Text
            Implements group rings and the meataxe algorithm to compute the irreducibility of a finite dimensional representation over a finite field.

///
doc ///
    Key
        groupRing
    Headline
        Constructor for GroupRing
    Usage
        groupRing(G,K)
    Inputs
        G:
            A FiniteGroupAction specifying a group.
        K:
            A field. 
    Outputs
        :
            A group ring defined by group G and field K. 
    Description
        Text
            Takes a FiniteGroupAction G and a field K and creates a group ring from them. 
        Example
            R = QQ[x1,x2,x3];
            L = {matrix {{0,1,0},{1,0,0},{0,0,1}}, matrix {{0,0,1},{0,1,0},{1,0,0}}, matrix {{1,0,0},{0,0,1},{0,1,0}} };
            G = finiteAction(L,R);
            groupRing(G,QQ)
///
doc ///
    Key
        meataxe        
    Headline
        Boolean function implementing the meataxe algorithm determining the irreducibility of a finite group representation of a finite dimensional vector space. If the module is irreducible, returns true. Otherwise, the method returns a nontrivial submodule. 
    Usage
        T = meataxe(G,S,K)
    Inputs
        G:FiniteGroupAction
            A finite group action
        S:FreeAlgebraQuotient
            A KG-algebra
        K:Ring
            The underlying field of the other parameters.
    Outputs
        T:Boolean
            Returns true if the Meataxe algorithm states that the K[G]-module is irreducible. Returns false if the module is reducible. 
///
TEST ///
        K = ZZ/3;
        R = ZZ/3[x1,x2];
        L= {matrix {{0,1},{1,0}},matrix {{2,0},{0,1}},matrix {{0,1},{2,0}},matrix {{1,0},{0,1}}};
        G = finiteAction(L,R);
        KG = groupRing(G,K);
        assert ( meataxe(G,KG,K));
/// 
TEST ///
        K = ZZ/3;
        R = K[x1,x2,x3,x4];
        L = {matrix {{0,1,0,0},{1,0,0,0},{0,0,1,0},{0,0,0,1}}, matrix {{1,0,0,0},{0,1,0,0},{0,0,0,1},{0,0,1,0}}};
        G = finiteAction(L,R);
        KG = groupRing(G,K);
        assert (rank meataxe(G,KG,K) <= 4);
///
end--
