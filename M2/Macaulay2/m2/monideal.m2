-- Copyright 1995 by Michael Stillman

MonomialIdeal = new Type of MutableHashTable
monomialIdeal = method()
numgens MonomialIdeal := I -> I.numgens
document { quote MonomialIdeal,
     TT "MonomialIdeal", " -- the class of all monomial ideals handled by
     the ", TO "engine", ".",
     PARA,
     "Routine for making monomial ideals:",
     MENU {
	  TO "monomialIdeal"
	  },
     PARA,
     "Operations on monomial ideals:",
     MENU {
	  TO "==",
	  TO "+",
	  TO "*",
	  TO "^",
	  TO ":",
	  TO "borel",
	  TO "codim",
	  TO "poincare",
	  TO "intersect",
	  TO "isBorel",
	  TO "generators",
	  TO "minprimes",
	  TO "radical",
	  TO "saturate",
	  TO "dual",
	  TO "-", "(I,J) -- compute { m minimal generator of I : m not a minimal gen of J",
	  TO "complement","(I) -- compute { m^c : m minimal generator of I }, where
		m^c is the product of the variables not in the support of m.",
	  TO "complement","(I,p) -- compute { p/m : m in I }, where p is a given monomial",
	  TO "top"
	  }
     }

generators(MonomialIdeal) := (I) -> (
     R := ring I;
     sendgg(ggPush I, ggmatrix);
     getMatrix R)

newMonomialIdeal := R -> (
     mi := new MonomialIdeal;
     sendgg(ggdup, gglength);
     mi.numgens = eePopInt();
     mi.handle = newHandle();
     mi.ring = R;
     mi)

name MonomialIdeal := m -> "monomialIdeal " | name matrix m

UnaryMonomialIdealOperation := (operation) -> (m) -> (
     sendgg (ggPush m, operation);
     newMonomialIdeal ring m)

BinaryMonomialIdealOperation := (operation) -> (m,n) -> (
     sendgg (ggPush m, ggPush n, operation);
     newMonomialIdeal ring m)

net MonomialIdeal := I -> (
     if I == 0 then "0"
     else (
	  "monomialIdeal " | verticalJoin apply(
	       lines sendgg(ggPush I,ggsee,ggpop), 
	       x -> concatenate ("| ",x,"|")
	       )
	  )
     )

MonomialIdeal ^ ZZ := (I,n) -> SimplePowerMethod(I,n)

monomialIdeal MonomialIdeal := I -> (
     if instance(I, MonomialIdeal) then (
          sendgg(ggPush I, ggcopy);
          newMonomialIdeal ring I))

monomialIdeal Matrix := f -> (
     sendgg(ggPush f, ggPush 0, ggmonideal);
     newMonomialIdeal ring f)

monomialIdeal(ZZ,Matrix) := (i,m) -> (
     sendgg(ggPush m, ggPush i, ggmonideal);
     newMonomialIdeal ring m)

document { quote monomialIdeal,
     TT "monomialIdeal f", " -- create a monomial ideal from a 1 by n matrix f.",
     BR,NOINDENT,
     TT "monomialIdeal I", " -- create a copy of a monomial ideal I.",
     BR,NOINDENT,
     TT "monomialIdeal(i,f)", " -- create a monomial ideal from a matrix f
     generated by those columns of f whose lead terms are in row i.",
     PARA,
     EXAMPLE "R=ZZ/101[a,b,c]",
     EXAMPLE "m = monomialIdeal vars R",
     EXAMPLE "m^2",
     EXAMPLE "m^3"
     }

MonomialIdeal == MonomialIdeal := (m,n) -> (
     sendgg (ggPush m, ggPush n, ggisequal); 
     eePopBool())

MonomialIdeal == ZZ := (m,i) -> (
     if i === 0 then numgens m == 0
     else error "asked to compare monomial ideal to nonzero integer")
ZZ == MonomialIdeal := (i,m) -> m == i
TEST "
R=ZZ/101[x]
assert(monomialIdeal vars R != 0)
assert(monomialIdeal map(R^1,0) == 0)
"

MonomialIdeal +  MonomialIdeal := {MonomialIdeal, BinaryMonomialIdealOperation ggadd}
MonomialIdeal *  MonomialIdeal := {MonomialIdeal, BinaryMonomialIdealOperation ggmult}


radical MonomialIdeal := (I,options) -> (UnaryMonomialIdealOperation ggradical) I
--document { quote radical,
--     TT "radical I", " -- compute the radical of a ", TO "MonomialIdeal", " I.",
--     PARA,
--     EXAMPLE "R = ZZ/101[a,b,c]",
--     EXAMPLE "I = monomialIdeal vars R",
--     EXAMPLE "J = I^3",
--     EXAMPLE "radical J"
--     }

--MonomialIdeal : Monomial := BinaryMonomialIdealOperation ggdiv
MonomialIdeal : MonomialIdeal := BinaryMonomialIdealOperation ggdiv

saturate(MonomialIdeal, MonomialIdeal) := (I,J,options) -> (
     (BinaryMonomialIdealOperation ggsat) (I,J)
     )

int := BinaryMonomialIdealOperation ggintersect

intersect(Sequence) := args -> (
    -- first check that all modules have the same target
    -- and the same base ring
    if #args === 0 then error "expected at least one argument";
    M := args#0;
    R := ring M;
    if class M === MonomialIdeal then (
	 if not all(args, M -> class M === MonomialIdeal and R === ring M)
	 then error "expected monomial ideals over the same ring";
	 i := 1;
	 while i < #args do (
	      M = int(M,args#i);
	      i = i+1;
	      );
	 M)
    else if class M === Module then (
    	 F := ambient args#0;
	 if not all(args, N -> ambient N == F)
	 or M.?relations 
	 and not all(args, N -> 
	      N.?relations 
	      and (N.relations == M.relations
		   or
		   image N.relations == image M.relations
		   )
	      )
    	 then error "all modules must be submodules of the same module";
    	 relns := directSum apply(args, N -> (
		   if N.?relations 
		   then generators N | N.relations
		   else generators N
		   )
	      );
    	 g := map(R^(#args),R^1, table(#args,1,x->1)) ** id_F;
	 h := modulo(g, relns);
	 if M.?relations then h = compress( h % M.relations );
    	 subquotient( h, if M.?relations then M.relations )
	 )
    else if class M === Ideal then (
	 ideal intersect apply(args,module)
	 )
    else error "expected modules, ideals, or monomial ideals"
    )

TEST "
R = ZZ/101[x,y]
assert( 
     intersect(image matrix {{1},{x}}, image matrix {{x}, {x^2}}) 
     == image matrix {{x}, {x^2}}
     )
assert(
     intersect(image matrix {{1},{x}}, image matrix {{x}, {x^3}}) ==  0
     )
assert( intersect( ideal(x^2,y), ideal (x,y^2)) == ideal (y^2, x^2, x*y) )
"

TEST "
R = ZZ/101[a..d]
assert(
     intersect(
	  subquotient(matrix {{a}},matrix {{d}}),
	  subquotient(matrix {{b}},matrix{{d}})
	  )
     ==
     subquotient(matrix {{a*b}},matrix {{d}})
     )
"

document { quote intersect,
     TT "intersect(M,N,...)", " -- calculate the intersection of 
     submodules of the same free module, or of monomial ideals."
     }

borel MonomialIdeal := UnaryMonomialIdealOperation ggborel
isBorel MonomialIdeal := m -> (
     sendgg(ggPush m, ggisborel);
     eePopBool())
document { quote isBorel,
     TT "isBorel I", " -- determine whether a ", TO "MonomialIdeal", " I
     is fixed by the action of the Borel subgroup of upper triangular
     matrices acting on the variables."
     }

codim MonomialIdeal := m -> (
     sendgg(ggPush m, ggcodim);
     eePopInt())

poincare MonomialIdeal := M -> ( --poincare matrix m
     R := ring M;
     ZZn := degreesRing(R);
     if not M.?poincare then (
	if not M.?poincareComputation then (
	    sendgg(ggPush ZZn, ggPush M, gghilb);
	    M.poincareComputation = newHandle());
        sendgg(ggPush M.poincareComputation, ggPush (-1), ggcalc);
	sendgg(ggPush M.poincareComputation, gggetvalue);
        M.poincare = ZZn.pop());
     M.poincare)

minprimes MonomialIdeal := m -> (
     sendgg(ggPush m, ggprimes);
     newMonomialIdeal ring m)
document { quote minprimes,
     TT "minprimes I", " -- compute the minimal primes of a monomial ideal I.",
     PARA,
     "Not working yet."
     }
