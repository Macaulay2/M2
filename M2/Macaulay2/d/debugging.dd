use util;
use tokens;
use common;
use evaluate;
use sets;

disassemble(e:Expr):Expr := (
    when e
    is f:FunctionClosure do toExpr(tostring(Code(f.model)))
    is f:functionCode do toExpr(tostring(Code(f)))
    is c:PseudocodeClosure do toExpr(tostring(c.code))
    is s:SpecialExpr do disassemble(s.e)
    else WrongArg("pseudocode or a function closure derived from Macaulay 2 code"));
setupfun("disassemble", disassemble);

pseudocode(e:Expr):Expr := (
    when e
    is f:FunctionClosure do Expr(PseudocodeClosure(f.frame, Code(f.model)))
    is f:functionCode do Expr(Pseudocode(f.body))
    is s:SpecialExpr do pseudocode(s.e)
    else WrongArg("a function derived from Macaulay2 code"));
setupfun("pseudocode", pseudocode);

export filePositionClass := newHashTableWithHash(typeClass, basicListClass);
setupconst("FilePosition", Expr(filePositionClass));

locate(p:Position):Expr := (
    if p == dummyPosition || p == tempPosition
    then nullE
    else Expr(sethash(List(filePositionClass,
		Sequence(
		    toExpr(verifyMinimizeFilename(p.filename)),
		    toExpr(int(p.line1)), toExpr(int(p.column1)),
		    toExpr(int(p.line2)), toExpr(int(p.column2)),
		    toExpr(int(p.line)), toExpr(int(p.column))),
		hash_t(0), false), false)));

locate(e:Expr):Expr := (
    when e
    is Nothing do nullE
    is Sequence do locate(lookupfun(e))
    is f:FunctionClosure do locate(f.model.position)
    is f:functionCode    do locate(f.position)
    -- TODO: can we use binary debug symbols?
    is CompiledFunction        do nullE
    is CompiledFunctionBody    do nullE
    is CompiledFunctionClosure do nullE
    is c:PseudocodeClosure do locate(codePosition(c.code))
    is c:Pseudocode        do locate(codePosition(c.code))
    is s:SymbolClosure do locate(s.symbol.position)
    is s:SpecialExpr do locate(s.e)
    else WrongArg("a function, symbol, sequence, or null"));
setupfun("locate", locate).Protected = false; -- will be overloaded in m2/methods.m2
