--		Copyright 1994-2000 by Daniel R. Grayson

newStartupMethod := true;				    -- for testing purposes
use evaluate;
use parser;
use texmacs;
use actors5;
import dirname(s:string):string;

export dummyError := Error(dummyPosition,"dummy error message",nullE,false,dummyFrame);

export setupargv():void := (
     setupconst("commandLine",toExpr(argv));
     setupconst("environment",toExpr(envp));
     );

export fileExitHooks := setupvar("fileExitHooks", Expr(emptyList));
export currentFileName := setupvar("currentFileName", nullE);
export currentPosFile  := dummyPosFile;
export currentFileDirectory := setupvar("currentFileDirectory", toExpr("./"));
export update(err:Error,prefix:string,f:Code):Error := (
     if !err.printed
     then printErrorMessage0(f,prefix + ": " + err.message)
     else printErrorMessage0(f,prefix + ": --backtrace update-- ")
     );
export previousLineNumber := -1;

export BeforeEval := makeProtectedSymbolClosure("BeforeEval");
export AfterEval := makeProtectedSymbolClosure("AfterEval");
export BeforePrint := makeProtectedSymbolClosure("BeforePrint");
export Print := makeProtectedSymbolClosure("Print");
export NoPrint := makeProtectedSymbolClosure("NoPrint");
export AfterPrint := makeProtectedSymbolClosure("AfterPrint");
export AfterNoPrint := makeProtectedSymbolClosure("AfterNoPrint");
export runmethod(methodname:SymbolClosure,g:Expr):Expr := (
     method := lookup(Class(g),methodname);
     if method == nullE then g else applyEE(method,g)
     );
export runmethod(methodname:Expr,g:Expr):Expr := (
     method := lookup(Class(g),methodname);
     if method == nullE then g else applyEE(method,g)
     );

export endInput := makeProtectedSymbolClosure("end");

PrintOut(g:Expr,semi:bool,f:Code):Expr := (
     methodname := if semi then NoPrint else Print;
     method := lookup(Class(g),methodname);
     if method == nullE 
     then printErrorMessageE(f,"no method for '" + methodname.symbol.word.name + "'")
     else applyEE(method,g)
     );

interpreterDepthS := setupvar("interpreterDepth",zeroE);
incrementInterpreterDepth():void := (
     interpreterDepth = interpreterDepth + 1;
     setGlobalVariable(interpreterDepthS,toExpr(interpreterDepth)));
decrementInterpreterDepth():void := (
     interpreterDepth = interpreterDepth - 1;
     setGlobalVariable(interpreterDepthS,toExpr(interpreterDepth)));


import readeval3(file:TokenFile,printout:bool,dc:DictionaryClosure,returnLastvalue:bool,stopIfBreakReturnContinue:bool,returnIfError:bool):Expr;
import readeval(file:TokenFile,returnLastvalue:bool,returnIfError:bool):Expr;

InputPrompt := makeProtectedSymbolClosure("InputPrompt");
InputContinuationPrompt := makeProtectedSymbolClosure("InputContinuationPrompt");

promptcount := 0;
topLevelPrompt():string := (
     if debugLevel == 123 then (
	  stderr <<  "-- topLevelPrompt:" 
	  << " previousLineNumber = " << previousLineNumber 
	  << "; lineNumber = " << lineNumber 
	  << endl;
	  );
     method := lookup(
	  ZZClass,
	  list(topLevelMode, Expr(if lineNumber == previousLineNumber then InputContinuationPrompt else (previousLineNumber = lineNumber; InputPrompt))));
     p := (
	  if method == nullE then ""
     	  else when applyEE(method,toExpr(lineNumber)) is s:stringCell do s.v
     	  is n:ZZcell do if isInt(n) then blanks(toInt(n)) else ""
     	  else "\n<--bad prompt--> : " -- unfortunately, we are not printing the error message!
	  );
     if debugLevel == 123 then (
	  p = "[" + tostring(promptcount) + "]  " + p;
	  stderr <<  "-- topLevelPrompt:" 
	  << " prompt = \"" << presentn(p) << "\""
	  << endl;
	  );
     promptcount = promptcount + 1;
     p);

loadprintstdin(dc:DictionaryClosure,stopIfBreakReturnContinue:bool,returnIfError:bool):Expr := (
     when openTokenFile("-")
     is e:errmsg do buildErrorPacket(e.message)
     is file:TokenFile do (
	  if !file.posFile.file.fulllines		    --texmacs !
	  then setprompt(file,topLevelPrompt);
	  r := readeval3(file,true,dc,false,stopIfBreakReturnContinue,returnIfError);
	  file.posFile.file.eof = false; -- erase eof indication so we can try again (e.g., recursive calls to topLevel)
	  r));

loadprint(filename:string,dc:DictionaryClosure,returnIfError:bool):Expr := (
     when openTokenFile(filename)
     is errmsg do False
     is file:TokenFile do (
	  if file.posFile.file != stdIO then file.posFile.file.echo = true;
	  if !file.posFile.file.fulllines		    --texmacs !
	  then setprompt(file,topLevelPrompt);
	  r := readeval3(file,true,dc,false,false,returnIfError);
	  t := (
	       if filename === "-"			 -- whether it's stdIO
	       then (
		    file.posFile.file.eof = false; -- erase eof indication so we can try again (e.g., recursive calls to topLevel)
		    0
		    )
	       else close(file));
	  when r is err:Error do (
	       if err.message == returnMessage
	       || err.message == continueMessage || err.message == continueMessageWithArg
	       || err.message == stepMessage || err.message == stepMessageWithArg
	       || err.message == breakMessage then if err.value == dummyExpr then nullE else err.value else r
	       )
	  else (
	       if t == ERROR
	       then buildErrorPacket("error closing file") 
	       else nullE)));
load(filename:string):Expr := (
     when openTokenFile(filename)
     is e:errmsg do buildErrorPacket(e.message)
     is file:TokenFile do (
	  r := readeval(file,true,true);
	  t := if !(filename==="-") then close(file) else 0;
	  when r is err:Error do (
	       if err.message == returnMessage
	       || err.message == continueMessage || err.message == continueMessageWithArg
	       || err.message == stepMessage || err.message == stepMessageWithArg
	       || err.message == breakMessage then if err.value == dummyExpr then nullE else err.value else r
	       )
	  else (
	       if t == ERROR
	       then buildErrorPacket("error closing file") 
 	       else r)));

load(e:Expr):Expr := (
     when e
     is s:stringCell do load(s.v)
     else buildErrorPacket("expected string as file name"));
setupfun("simpleLoad",load);

currentLineNumber(e:Expr):Expr := (
     when e is s:Sequence do
     if length(s) == 0 then toExpr(int(currentPosFile.line))
     else WrongNumArgs(0)
     else WrongNumArgs(0));
setupfun("currentLineNumber",currentLineNumber);

input(e:Expr):Expr := (
     when e
     is f:stringCell do (
	  filename := f.v;
	  -- we should have a way of setting normal prompts while inputting
     	  incrementInterpreterDepth();
	  ret := loadprint(filename,newStaticLocalDictionaryClosure(filename),true);
     	  decrementInterpreterDepth();
	  previousLineNumber = -1;
	  ret)
     else buildErrorPacket("expected string as file name"));
setupfun("simpleInput",input);

stringTokenFile(name:string,contents:string):TokenFile := (
     TokenFile(
	  makePosFile(
	  newFile(name,	 		  -- filename
	       0,			  -- pid
	       false,	       	    	  -- error
	       "",     	    	      	  -- message
	       false,	       	    	  -- listener
	       NOFD,   	    	          -- listenerfd
	       NOFD,	      	   	  -- connection
	       0,     	   	     	  -- numconns
	       true,			  -- input
	       NOFD,			  -- infd
	       false,			  -- inisatty
	       contents,		  -- inbuffer
	       0,			  -- inindex
	       length(contents),	  -- insize
	       true,			  -- eof
	       false,	  		  -- promptq
	       noprompt,		  -- prompt
	       noprompt,		  -- reward
	       false,			  -- fulllines
     	       true,	       	    	  -- bol
	       false,			  -- echo
	       0,			  -- echoindex
	       false,			  -- output
	       NOFD,			  -- outfd
	       false,			  -- outisatty
	       "",			  -- outbuffer
	       0,			  -- outindex
	       0,     	   	     	  -- outbol
	       false,	       	    	  -- hadNet
	       dummyNetList,   	      	  -- nets
	       0,		          -- bytesWritten
	       -1,		          -- lastCharOut
	       false,                     -- readline
	       0                          -- threadState
	       )),
	  NULL));

export topLevel():bool := (
     when loadprint("-",newStaticLocalDictionaryClosure(),false)
     is err:Error do (
	  -- printErrorMessage(err);		    -- this message may not have been printed before (?)
	  false)
     else true
     );

commandInterpreter(dc:DictionaryClosure):Expr := loadprint("-",dc,false);
commandInterpreter(f:Frame):Expr := commandInterpreter(newStaticLocalDictionaryClosure(localDictionaryClosure(f)));
commandInterpreter(e:Expr):Expr := (
     incrementInterpreterDepth();
       ret := 
       when e is s:Sequence do (
	    if length(s) == 0 then loadprint("-",newStaticLocalDictionaryClosure(),false)
	    else WrongNumArgs(0,1)
	    )
       is Nothing do loadprint("-",newStaticLocalDictionaryClosure(),false)
       is x:DictionaryClosure do commandInterpreter(x)
       is x:SymbolClosure do commandInterpreter(x.frame)
       is x:CodeClosure do commandInterpreter(x.frame)
       is x:FunctionClosure do commandInterpreter(x.frame)
       is cfc:CompiledFunctionClosure do commandInterpreter(emptyFrame)	    -- some values are there, but no symbols
       is CompiledFunction do commandInterpreter(emptyFrame)		    -- no values or symbols are there
       is s:SpecialExpr do commandInterpreter(s.e)
       else WrongArg("a function, symbol, dictionary, pseudocode, or ()");
     decrementInterpreterDepth();
     --setLoadDepth(saveLoadDepth);
     ret);
setupfun("commandInterpreter",commandInterpreter);

currentS := setupvar("current",nullE);
debugger(f:Frame,c:Code):Expr := (
     -- stdIO << "-- recursionDepth = " << recursionDepth << endl;
     oldrecursionDepth := recursionDepth;
     recursionDepth = 0;
     setDebuggingMode(false);
       oldDebuggerCode := getGlobalVariable(currentS);
       setGlobalVariable(currentS,Expr(CodeClosure(f,c)));
	 incrementInterpreterDepth();
	   if debuggerHook != nullE then (
		r := applyEE(debuggerHook,True);
		when r is Error do return r else nothing;
		);
	   ret := loadprintstdin(newStaticLocalDictionaryClosure(localDictionaryClosure(f)),true,false);
	   if debuggerHook != nullE then (
		r := applyEE(debuggerHook,False);
		when r is Error do return r else nothing;
		);
	 decrementInterpreterDepth();
       setGlobalVariable(currentS,oldDebuggerCode);
     setDebuggingMode(true);
     recursionDepth = oldrecursionDepth;
     ret);
debuggerFun = debugger;

export currentString := setupvar("currentString", nullE);
import value(e:Expr):Expr;
setupfun("value",value).Protected = false;

tmpbuf := new string len 100 do provide ' ' ;

--May need thread work?
internalCapture(e:Expr):Expr := (
     when e
     is s:stringCell do (
     	  flush(stdIO);
	  oldfd := stdIO.outfd;
	  oldDebuggingMode := debuggingMode;
	  setDebuggingMode(false);
	  oldStderrE := getGlobalVariable(stderrS);
	  oldstderr := stdError;
	  stdError = stdIO;
	  setGlobalVariable(stderrS,getGlobalVariable(stdioS));
          foss := getFileFOSS(stdIO);
	  --thread workaround -- unlock fileFOSS
	  releaseFileFOSS(stdIO);
	  stdIO.outfd = NOFD;
	  oldbuf := foss.outbuffer;
	  foss.outbuffer = tmpbuf;
	  stringFile := stringTokenFile("currentString", s.v+newline);
	  stringFile.posFile.file.echo = true;
	  oldLineNumber := lineNumber;
	  previousLineNumber = -1;
	  setLineNumber(0);
	  setprompt(stringFile,topLevelPrompt);
	  r := readeval3(stringFile,true,newStaticLocalDictionaryClosure(),false,false,true);
	  out := substrAlwaysCopy(foss.outbuffer,0,foss.outindex);
	  stdIO.outfd = oldfd;
	  foss.outbuffer = oldbuf;
	  foss.outindex = 0;
	  setGlobalVariable(stderrS,oldStderrE);
	  stdError = oldstderr;
	  setLineNumber(oldLineNumber);
	  setDebuggingMode(oldDebuggingMode);
	  previousLineNumber = -1;
	  Expr(Sequence( when r is err:Error do True else False, toExpr(out) )))
     else WrongArg(1,"a string"));
setupfun("internalCapture",internalCapture);

-- Local Variables:
-- compile-command: "echo \"make: Entering directory \\`$M2BUILDDIR/Macaulay2/d'\" && make -C $M2BUILDDIR/Macaulay2/d interp.o "
-- End:
