// -*- c++ -*-

#if 0

/*

gcd now works over GF, so work on factoring
-----------------------------------------------------------------------------
From: hannes@mathematik.uni-kl.de
Subject: Re: Singular Factory
To: dan@math.uiuc.edu
Date: Mon, 27 Oct 2008 18:32:18 +0100 (CET)
In-Reply-To: <200810250230.m9P2Ug1Z012463@u123.math.uiuc.edu> from "Daniel R. Grayson" at Oct 24, 2008 09:30:42 PM

//  
//  
//  Does factory support factorization or gcd over algebraic extensions generated
//  by more than one element?
//  
Factorize and alg_gcd do.

Hans
-----------------------------------------------------------------------------
From: hannes@mathematik.uni-kl.de
Subject: Re: Singular Factory
To: dan@math.uiuc.edu
Date: Tue, 7 Nov 2006 09:36:13 +0100 (CET)
Cc: hannes@mathematik.uni-kl.de
In-Reply-To: <200611031821.kA3IL8Jv018521@u123.math.uiuc.edu> from "Dan Grayson" at Nov 03, 2006 12:21:08 PM

// 
// 
//  Hi, Hannes,
// 
//  It was good to see you at the IMA.
// 
//  How would I hook up M2 to Singular/Factory so it can factor and do gcd's over
//  non-prime finite fields?  Can I specify the irreducible polynomial of the
//  generator of the finite field?  If so, must its root generate the
//  multiplicative group?
// 
Hi Dan,
factory assumes only, that the minimal polynomial of the field extension is
given as a irreducible polynomial.
(There is also another representation, which uses the root
of the multiplicative group, but we do not use it, so its untested.)

GCD:

    This one should now work in char 0 also:

	Here an example for gcd in a field extension of Z/p by mipo
	(a polynomial of type CanonicalForm):
	  setCharacteristic(p);
	  Variable a=rootOf(mipo);
	  // build F and G using a to represent a root of mipo
	  return gcd(F,G);

    This one should not be needed any longer:

	for extentions of Q:
	  setCharacteristic(0);
	  CFList as(mipo);
	  Variable a=rootOf(mipo);
	  // build F and G using a to represent a root of mipo
	  return  alg_gcd( F, G, as);

Factorization:

    And factorization of G:
      setCharacteristic(p); // resp. setCharacteristic(0);
      Variable a=rootOf(mipo);
      // build G using a to represent a root of mipo
      CFFList L=Factorize(G, mipo);     // <<<=== no, this should be factorize, instead, if you use mipo, and it's only for polynomials in 1 variable


-----------------------------------------------------------------------------
From: hannes@mathematik.uni-kl.de
Subject: Re: Singular Factory
To: dan@math.uiuc.edu
Date: Wed, 5 Nov 2008 18:45:27 +0100 (CET)
Cc: hannes@mathematik.uni-kl.de
In-Reply-To: <no.id> from "Daniel R. Grayson" at Nov 04, 2008 02:37:04 PM

//  
//  
//  I tried to figure it out (how to do it) and couldn't.  I can't even use the
//  result of one rootOf as part of the input to the next one.  And since Factorize
//  takes one minimal polynomial as its second argument, it's counterintuitive that
//  it could handle much more.
//  
//  Can you tell me how to do it?

Sorry, rootOf is used in factory, but not in libfac,
and libfac provides that stuff:

For factorization/gcd in that case one should use 
CFFList newfactoras( const CanonicalForm & f, const CFList & as, int success)
(from libfac/factor.h)
example:
CFList as(mipo); // polynomial in Var(1)
as.append(mipo2); // polynomial in Var(1), Var(2)
CanonicalForm F=....; // polynomial in Var(1)...Var(n), Var(1) and Var(2)
                      // considered as algebraic variables accouding to mipo,mipo2

CanonicalForm G=....;

CanonicalForm result= alg_gcd( F, G, as);

int success=-1;
CFFList qs=newfactoras(F,as,success);

Hans
-----------------------------------------------------------------------------

The problem is that the code below gives the wrong answer.  It is a bug
in factory, not fixed yet in version 3.1.3.  To work around it, test
the answer by multiplying.  If it is wrong, just try again.

    #include <factor.h>
    using std::cout;
    using std::endl;
    int main () {
      factoryseed(123);
      Off( SW_RATIONAL );
      setCharacteristic(101);
      Variable a('a'), x('x');
      CanonicalForm mipo = a*a - 2, f = x*x-2;
      cout << "f = " << f << endl;
      cout << "Factorize(f,mipo) = " << Factorize(f,mipo) << endl;
      return 0;
    }

-----------------------------------------------------------------------------

latest word on how to factor polynomials over extension fields:

Date: Fri, 3 Feb 2012 15:57:10 +0100
From: Hans Schoenemann <hannes@mathematik.uni-kl.de>
To: "Grayson, Daniel R." <dan@math.uiuc.edu>
Subject: Re: [Singular-users] Singular-3-1-4 is available
Message-ID: <20120203145710.GS6760@mathematik.uni-kl.de>

On Tue, Jan 31, 2012 at 12:15:36PM -0600, Grayson, Daniel R. wrote:
> Hi, Hannes.
> 
> Will the factory and libfac libraries get new versions, too?
> 
> 
Hi Dan,
yes, we have also new version of factory and libfac.
Interface changes:
- the type to convert CananicalForm to/from long integers is not MP_INT
  any more, but mpz_t
- factorize should handle polynomial factorization for all
  ground fields, Factorize (and its wrappers) is depreciated
  (but still used internally for characteristic sets)
- gcd should handle gcd computations for all ground fields,
  algcd and alg_gcd are depreciated

Concerning the factory bugs: 
- computation over ZZ versus computation over QQ
  in principle, one should use for QQ:
    setCharacteristic(0); On(SW_RATIONAL);
  and for ZZ:
    setCharacteristic(0); Off(SW_RATIONAL);
  but it seems that some parts require the coefficients in ZZ,
  so it is best to multiply polynomials by their common denominator
  and use Off(SW_RATIONAL);
- "coefficient not immidiate" in ZZ/2 hould be gone with the
  new factorization code.

Hannes

*/

#endif


#include <factor.h>
using std::cout;
using std::endl;
int main () {
  factoryseed(123);
  Off( SW_RATIONAL );
  setCharacteristic(101);
  Variable a('a'), x('x');
  CanonicalForm mipo = a*a - 2;
  Variable b = rootOf(mipo);
  CanonicalForm g = x*x - b;
  cout << "g = " << g << endl;
  cout << "factorize(g) = " << factorize(g) << endl;
  return 0;
}

// Local Variables:
// compile-command: "g++ -g -I$M2BUILDDIR/libraries/final/include -L$M2BUILDDIR/libraries/final/lib -x c++ 1-factor -lfac -lcf -lcfmem -lntl -lgmp -o 1-factor.exe && (ulimit -v 100000 -t 1 ; set -x ; time ./1-factor.exe)"
// End:
